<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChromaShock Arena (炫彩衝擊競技場)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #000000; /* Pure black background for visual contrast */
            color: #FFFFFF; /* Default text color */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            display: block;
            background-color: #050515; /* Very dark navy for space background */
            border: 2px solid #00FFFF; /* Cyan border */
            box-shadow: 0 0 20px 5px rgba(0, 255, 255, 0.5); /* Cyan glow */
        }

        .ui-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85); /* Semi-transparent black */
            border: 2px solid #00CCFF; /* Cyan border */
            box-shadow: 0 0 25px 8px rgba(0, 204, 255, 0.6); /* Stronger cyan glow */
            padding: 30px 40px;
            text-align: center;
            border-radius: 10px;
            max-width: 90%;
            display: none; /* Hidden by default */
            z-index: 1000; /* Ensure UI is on top */
        }

        .ui-screen h1, .ui-screen h2 {
            color: #00FFFF; /* Bright cyan for titles */
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00FFFF;
        }

        .ui-screen p {
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        .ui-screen button {
            background-color: #00CCFF; /* Cyan button */
            color: #000000; /* Black text */
            border: none;
            padding: 12px 25px;
            margin: 10px;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
        }

        .ui-screen button:hover {
            background-color: #00FFFF; /* Lighter cyan on hover */
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }

        .ui-screen button:active {
            transform: translateY(0);
        }

        /* HUD Overlay */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow mouse events to pass through to canvas */
            display: none; /* Hidden by default */
        }

        #score-display, #wave-display, #health-bar-container, #laser-charge-container {
            position: absolute;
            color: #FFFFFF;
            font-size: 1.5em;
            text-shadow: 0 0 5px #00FFFF;
        }

        #score-display { top: 20px; left: 20px; }
        #wave-display { top: 60px; left: 20px; }

        #health-bar-container {
            top: 100px;
            left: 20px;
            width: 200px; /* Fixed width for health bar */
            height: 20px;
            background-color: rgba(255, 0, 255, 0.3); /* Magenta transparent background */
            border: 2px solid #FF00FF; /* Magenta border */
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 0 8px rgba(255, 0, 255, 0.5);
        }

        #health-bar {
            height: 100%;
            width: 100%; /* Will be updated by JS */
            background-color: #00FFFF; /* Cyan fill */
            transition: width 0.1s linear; /* Smooth health change */
            box-shadow: 0 0 5px #00FFFF;
        }
        
        #laser-charge-container { /* New style for laser charge bar */
            top: 140px; /* Position below health bar */
            left: 20px;
            width: 200px; 
            height: 15px;
            background-color: rgba(0, 0, 0, 0.5); /* Dark background */
            border: 2px solid #FF00FF; /* Magenta border */
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 0 8px rgba(255, 0, 255, 0.5);
        }

        #laser-charge-bar {
            height: 100%;
            width: 0%; /* Starts empty */
            background-color: #FF00FF; /* Magenta fill */
            transition: width 0.05s linear; /* Fast transition */
            box-shadow: 0 0 5px #FF00FF;
        }


        #skill-hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 15px;
        }

        .skill-icon {
            width: 60px;
            height: 60px;
            border: 2px solid #00FFFF;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            font-weight: bold;
            color: #00FFFF;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .skill-cooldown {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            color: #FFFFFF;
            text-shadow: 0 0 5px #FFFFFF;
            pointer-events: none;
        }

        .skill-icon.ready {
            box-shadow: 0 0 15px #00FFFF, 0 0 25px rgba(0, 255, 255, 0.7);
        }

        /* Upgrade Screen */
        #upgrade-screen h2 {
            color: #00FFFF;
            margin-bottom: 20px;
            text-shadow: 0 0 8px #00FFFF;
        }

        #current-money {
            color: #FFFF00;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-shadow: 0 0 8px #FFFF00;
        }

        #upgrade-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            max-height: 60vh;
            overflow-y: auto;
            padding-right: 10px; /* For scrollbar */
        }

        .upgrade-item {
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #00CCFF;
            padding: 15px;
            border-radius: 8px;
            text-align: left;
            box-shadow: 0 0 10px rgba(0, 204, 255, 0.3);
            position: relative;
        }

        .upgrade-item h4 {
            color: #FF00FF; /* Magenta for category */
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        .upgrade-item h3 {
            color: #FFFF00; /* Yellow for item name */
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.3em;
        }

        .upgrade-item p {
            font-size: 0.9em;
            line-height: 1.4;
            color: #CCC;
            margin-bottom: 10px;
        }

        .upgrade-item .level-info {
            font-weight: bold;
            color: #00FFFF;
            margin-bottom: 5px;
        }

        .upgrade-item .cost-info {
            font-weight: bold;
            color: #FFFF00;
            margin-bottom: 10px;
        }
        .upgrade-item button {
            width: calc(100% - 20px); /* Adjust for padding */
            font-size: 0.95em;
            margin: 5px 0 0 0;
        }
        .upgrade-item button:disabled {
            background-color: rgba(0, 204, 255, 0.3);
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Game Over Screen & Pause Screen*/
        #game-over-menu h2, #pause-menu h2 {
            color: #FF00FF; /* Magenta */
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #FF00FF;
        }

        #game-over-menu p {
            color: #FF00FF; /* Magenta for stats */
            font-size: 1.5em;
            margin-bottom: 10px;
        }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- Main Menu -->
    <div id="main-menu" class="ui-screen">
        <h1>ChromaShock Arena</h1>
        <p>歡迎來到炫彩衝擊競技場！</p>
        <button id="start-game-btn">開始遊戲</button>
        <button id="upgrades-btn">永久升級</button>
        <p id="high-score-display">最高分數：0</p>
    </div>

    <!-- Upgrade Screen -->
    <div id="upgrade-screen" class="ui-screen">
        <h2>永久升級</h2>
        <p id="current-money">金錢：0</p>
        <div id="upgrade-list">
            <!-- Upgrade items will be dynamically inserted here -->
        </div>
        <button id="back-from-upgrades-btn">返回</button>
    </div>

    <!-- Game Over Menu -->
    <div id="game-over-menu" class="ui-screen">
        <h2>遊戲結束！</h2>
        <p>本局得分：<span id="final-score">0</span></p>
        <p>最高波次：<span id="final-wave">0</span></p>
        <p>獲得金錢：<span id="gained-money">0</span></p>
        <button id="return-to-main-menu-btn">返回主選單</button>
    </div>

    <!-- Pause Menu -->
    <div id="pause-menu" class="ui-screen">
        <h2>遊戲暫停</h2>
        <button id="resume-game-btn">繼續遊戲</button>
        <button id="exit-game-btn">退出遊戲</button>
    </div>

    <!-- HUD Overlay (Always present when game is running) -->
    <div id="ui-overlay">
        <div id="score-display">分數：0</div>
        <div id="wave-display">WAVE：1 | 剩餘敵人：0</div>
        <div id="health-bar-container">
            <div id="health-bar"></div>
        </div>
        <div id="laser-charge-container"> <!-- New element for laser charge bar -->
            <div id="laser-charge-bar"></div>
        </div>
        <div id="skill-hud">
            <div id="skill-q" class="skill-icon ready">Q<div class="skill-cooldown" style="display: none;"></div></div>
            <div id="skill-e" class="skill-icon ready">E<div class="skill-cooldown" style="display: none;"></div></div>
            <div id="skill-right-click" class="skill-icon ready">RMB<div class="skill-cooldown" style="display: none;"></div></div>
        </div>
    </div>

    <script>
        // === Constants and Game Configuration ===
        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 800;

        const PLAYER_MAX_HEALTH_BASE = 100;
        const PLAYER_MOVE_SPEED_BASE = 300; // pixels per second
        const PLAYER_FIRE_RATE_BASE = 8; // shots per second
        const PLAYER_BULLET_DAMAGE_BASE = 10;
        const PLAYER_HEALTH_REGEN_BASE = 0.5; // health per second
        const PLAYER_BULLETS_PER_SHOT_BASE = 1; 

        const SKILL_Q_DAMAGE_BASE = 40;
        const SKILL_Q_TARGETS_BASE = 4;
        const SKILL_Q_COOLDOWN = 8; // seconds

        const SKILL_E_DAMAGE_BASE = 20; 
        const SKILL_E_RADIUS_BASE = 200;
        const SKILL_E_KNOCKBACK_BASE = 50;
        const SKILL_E_COOLDOWN = 6; // seconds

        const SKILL_RMB_DAMAGE_BASE = 35; // damage per frame, UPDATED
        const SKILL_RMB_COOLDOWN = 10; // seconds - This is now the BASE time to fully recharge the laser from 0 to max charge

        // NEW: Laser Charge Configuration
        const PLAYER_LASER_DRAIN_PER_SECOND_BASE = 60; // How many charge units are consumed per second (base, for easier balancing)
        const PLAYER_LASER_ACTIVE_SECONDS_BASE = 1; // How many seconds the laser can fire from full charge (base)
        const PLAYER_LASER_MAX_CHARGE_BASE = PLAYER_LASER_DRAIN_PER_SECOND_BASE * PLAYER_LASER_ACTIVE_SECONDS_BASE; // Total charge units

        // Regenerate rate is calculated to match SKILL_RMB_COOLDOWN duration from empty to full at base level
        const PLAYER_LASER_CHARGE_REGEN_RATE_BASE = PLAYER_LASER_MAX_CHARGE_BASE / SKILL_RMB_COOLDOWN; // units per second
        
        const BULLET_SPEED = 800; // pixels per second
        const ENEMY_SPAWN_OFFSET = 50; // Spawn enemies this far off screen

        const WAVE_INITIAL_ENEMY_COUNT = 8;
        const WAVE_ENEMY_COUNT_PER_WAVE = 10; // UPDATED to 10
        const WAVE_ENEMY_HP_SCALING = 0.25; // UPDATED to 25%
        const WAVE_ENEMY_SPEED_SCALING = 0.001; // UPDATED to 0.1%
        const WAVE_SPAWN_INTERVAL_BASE = 500; // ms
        const WAVE_SPAWN_INTERVAL_DECREASE = 20; // ms per wave
        const WAVE_SPAWN_INTERVAL_MIN = 100; // ms

        // --- BOSS Constants ---
        const BOSS_WAVE_INTERVAL = 10;
        const BOSS_HEALTH_BASE = 50000; // UPDATED to 10x original (5000 * 10)
        const BOSS_SCORE_VALUE = 1000;
        const BOSS_SPEED = 50; // pixels per second for side-to-side movement
        const BOSS_MISSILE_FIRE_RATE = 2; // missiles per second
        const MISSILE_SPEED = 150; // pixels per second
        const MISSILE_TURN_RATE = Math.PI / 1.5; // radians per second
        const MISSILE_DAMAGE = 15; // Damage to player
        const BOSS_SHIELD_FLASH_DURATION = 100; // ms for shield flash effect

        // --- Colors ---
        const COLOR_PLAYER = '#00FFFF'; // Cyan
        const COLOR_PLAYER_BULLET = '#00FFFF'; // Cyan
        const COLOR_ENEMY_GRUNT = '#FF0000'; // Bright Red
        const COLOR_ENEMY_SCOUT = '#FFFF00'; // Bright Yellow
        const COLOR_ENEMY_BRUTE = '#FF00FF'; // Magenta
        const COLOR_EXPLOSION_PARTICLE = ['#FF0000', '#FFA500', '#FFFF00', '#FF00FF']; // Red, Orange, Yellow, Magenta
        const COLOR_SKILL_Q = '#CCFFFF'; // Light Cyan
        const COLOR_SKILL_E_INNER = '#FFFFFF'; // White
        const COLOR_SKILL_E_OUTER = '#FFA500'; // Orange
        const COLOR_SKILL_RMB = '#FF00FF'; // Magenta
        const COLOR_CROSSHAIR = '#FFFFFF'; // White for crosshair
        const COLOR_BOSS_BODY = '#2A0033'; // Deep Purple
        const COLOR_BOSS_ARMOR = '#4A1452'; // Darker Magenta/Purple
        const COLOR_BOSS_CORE = '#FF00FF'; // Bright Magenta
        const COLOR_MISSILE = '#FFA500'; // Orange
        const COLOR_MISSILE_TRAIL = '#FF4500'; // OrangeRed
        const COLOR_BOSS_SHIELD_FLASH = 'rgba(0, 255, 255, 0.7)'; // Cyan with alpha for shield

        // --- Permanent Upgrade Definitions ---
        const UPGRADES_DEFINITION = {
            'bulletDamage': {
                category: '基礎', name: '子彈傷害', effect: '提升每顆子彈的傷害',
                baseValue: PLAYER_BULLET_DAMAGE_BASE, increment: 2,
                initialPrice: 50, priceFactor: 1.35
            },
            'fireRate': {
                category: '基礎', name: '射擊頻率', effect: '提升每秒可發射的子彈數',
                baseValue: PLAYER_FIRE_RATE_BASE, increment: 1.10, type: 'multiply',
                initialPrice: 60, priceFactor: 1.4
            },
            'bulletsPerShot': { 
                category: '基礎', name: '多重射擊', effect: '每次射擊發射的子彈數量',
                baseValue: PLAYER_BULLETS_PER_SHOT_BASE, increment: 1,
                initialPrice: 75, priceFactor: 1.4 
            },
            'maxHealth': {
                category: '基礎', name: '最大生命', effect: '提升生命值上限',
                baseValue: PLAYER_MAX_HEALTH_BASE, increment: 25,
                initialPrice: 70, priceFactor: 1.38
            },
            'healthRegen': {
                category: '基礎', name: '生命恢復', effect: '提升每秒恢復的生命值',
                baseValue: PLAYER_HEALTH_REGEN_BASE, increment: 0.3,
                initialPrice: 90, priceFactor: 1.45
            },
            'moveSpeed': {
                category: '基礎', name: '移動速度', effect: '提升飛船的移動速度',
                baseValue: PLAYER_MOVE_SPEED_BASE, increment: 20,
                initialPrice: 80, priceFactor: 1.3
            },
            'waveRadius': {
                category: '波動 [E]', name: '半徑', effect: '增加波動攻擊的擴散半徑',
                baseValue: SKILL_E_RADIUS_BASE, increment: 25,
                initialPrice: 100, priceFactor: 1.42
            },
            'waveDamage': {
                category: '波動 [E]', name: '傷害', effect: '增加波動攻擊的傷害',
                baseValue: SKILL_E_DAMAGE_BASE, increment: 6,
                initialPrice: 120, priceFactor: 1.48
            },
            'waveKnockback': {
                category: '波動 [E]', name: '推力', effect: '增強波動對敵人的推開力度',
                baseValue: SKILL_E_KNOCKBACK_BASE, increment: 15,
                initialPrice: 90, priceFactor: 1.35
            },
            'lightningTargets': {
                category: '閃電 [Q]', name: '目標數', effect: '增加閃電鏈可彈射的敵人數量',
                baseValue: SKILL_Q_TARGETS_BASE, increment: 1,
                initialPrice: 150, priceFactor: 1.5
            },
            'lightningDamage': {
                category: '閃電 [Q]', name: '傷害', effect: '增加每次閃電的傷害',
                baseValue: SKILL_Q_DAMAGE_BASE, increment: 12,
                initialPrice: 180, priceFactor: 1.55
            },
            'laserMaxCharge': { 
                category: '雷射 [右鍵]', name: '最大充能', effect: '增加雷射武器的最大能量儲備',
                baseValue: PLAYER_LASER_MAX_CHARGE_BASE, increment: 10, // UPDATED
                initialPrice: 140, priceFactor: 1.52
            },
            'laserChargeRegen': { 
                category: '雷射 [右鍵]', name: '充能速度', effect: '提升雷射武器的能量恢復速度',
                baseValue: PLAYER_LASER_CHARGE_REGEN_RATE_BASE, increment: 1, // UPDATED
                initialPrice: 100, priceFactor: 1.45
            },
            'laserDamage': {
                category: '雷射 [右鍵]', name: '傷害', effect: '增加雷射每幀造成的傷害',
                baseValue: SKILL_RMB_DAMAGE_BASE, increment: 6,
                initialPrice: 200, priceFactor: 1.6
            }
        };

        // === Game State Variables ===
        let canvas, ctx;
        let animationFrameId;
        let lastTime = 0;
        let deltaTime = 0;

        let gameRunning = false;
        let gamePaused = false;
        let currentScreen = 'main-menu';

        let player;
        let enemies = [];
        let playerProjectiles = [];
        let particles = [];
        let lightningEffects = [];
        let waveEffects = []; 
        let boss = null; 
        let missiles = []; 

        let currentScore = 0;
        let currentWave = 1;
        let enemiesInWave = 0;
        let enemiesSpawnedThisWave = 0;
        let lastEnemySpawnTime = 0;
        let waveTextDisplayTime = 0;
        const WAVE_TEXT_DURATION = 2000;
        let isBossWave = false;

        // Permanent Player Data (stored in localStorage)
        let playerMoney = 0;
        let highScore = 0;
        let playerUpgradeLevels = {};

        // --- Mouse and Keyboard Input ---
        const keys = {}; 
        const mouse = { x: 0, y: 0, leftPressed: false, rightPressed: false };

        // === DOM Elements ===
        const mainMenu = document.getElementById('main-menu');
        const upgradeScreen = document.getElementById('upgrade-screen');
        const gameOverMenu = document.getElementById('game-over-menu');
        const pauseMenu = document.getElementById('pause-menu');
        const uiOverlay = document.getElementById('ui-overlay');
        const startGameBtn = document.getElementById('start-game-btn');
        const upgradesBtn = document.getElementById('upgrades-btn');
        const highScoreDisplay = document.getElementById('high-score-display');
        const currentMoneyDisplay = document.getElementById('current-money');
        const upgradeListDiv = document.getElementById('upgrade-list');
        const backFromUpgradesBtn = document.getElementById('back-from-upgrades-btn');
        const finalScoreDisplay = document.getElementById('final-score');
        const finalWaveDisplay = document.getElementById('final-wave');
        const gainedMoneyDisplay = document.getElementById('gained-money');
        const returnToMainMenuBtn = document.getElementById('return-to-main-menu-btn');
        const resumeGameBtn = document.getElementById('resume-game-btn');
        const exitGameBtn = document.getElementById('exit-game-btn');
        const scoreDisplay = document.getElementById('score-display');
        const waveDisplay = document.getElementById('wave-display');
        const healthBar = document.getElementById('health-bar');
        const laserChargeBar = document.getElementById('laser-charge-bar'); 
        const skillQIcon = document.getElementById('skill-q');
        const skillEIcon = document.getElementById('skill-e');
        const skillRMBIcon = document.getElementById('skill-right-click');

        // === Helper Functions ===
        function clamp(value, min, max) { return Math.max(min, Math.min(value, max)); }
        function dist(x1, y1, x2, y2) { const dx = x2 - x1; const dy = y2 - y1; return Math.sqrt(dx * dx + dy * dy); }
        
        // Object Pooling
        const pool = {
            projectiles: [],
            particles: [],
            missiles: [], 

            getProjectile() {
                return this.projectiles.length > 0 ? this.projectiles.pop() : new Projectile();
            },
            returnProjectile(proj) {
                if (proj.isActive) { 
                    proj.isActive = false; 
                    this.projectiles.push(proj);
                }
            },
            getParticle() {
                return this.particles.length > 0 ? this.particles.pop() : new Particle();
            },
            returnParticle(part) {
                if (part.isActive) {
                    part.isActive = false;
                    this.particles.push(part);
                }
            },
            getMissile() { 
                return this.missiles.length > 0 ? this.missiles.pop() : new Missile();
            },
            returnMissile(miss) { 
                if (miss.isActive || !miss.isDead) { 
                    miss.isActive = false;
                    miss.isDead = true; 
                    this.missiles.push(miss);
                }
            }
        };

        // --- localStorage Management ---
        function saveGame() {
            const gameData = {
                money: playerMoney,
                highScore: highScore,
                upgradeLevels: playerUpgradeLevels
            };
            localStorage.setItem('chromashockArenaData', JSON.stringify(gameData));
        }

        function loadGame() {
            let loadedUpgradeLevels = {};
            const savedData = localStorage.getItem('chromashockArenaData');
            if (savedData) {
                try {
                    const gameData = JSON.parse(savedData);
                    playerMoney = gameData.money || 0;
                    highScore = gameData.highScore || 0;
                    loadedUpgradeLevels = gameData.upgradeLevels || {};
                } catch (e) {
                    console.error("Failed to parse game data from localStorage, starting fresh.", e);
                    // Clear corrupted data if parsing fails
                    localStorage.removeItem('chromashockArenaData');
                }
            }

            // Initialize playerUpgradeLevels based on current UPGRADES_DEFINITION
            // and override with loaded data if available. This ensures forward compatibility.
            playerUpgradeLevels = {};
            for (const key in UPGRADES_DEFINITION) {
                playerUpgradeLevels[key] = loadedUpgradeLevels[key] !== undefined ? loadedUpgradeLevels[key] : 0;
            }
        }

        // --- UI Management ---
        function showScreen(screenId) {
            mainMenu.style.display = 'none';
            upgradeScreen.style.display = 'none';
            gameOverMenu.style.display = 'none';
            pauseMenu.style.display = 'none';
            uiOverlay.style.display = 'none';
            gameRunning = false;
            gamePaused = false;
            cancelAnimationFrame(animationFrameId);

            if (screenId === 'main-menu') {
                mainMenu.style.display = 'block';
                highScoreDisplay.textContent = `最高分數：${highScore}`;
            } else if (screenId === 'upgrade-screen') {
                upgradeScreen.style.display = 'block';
                populateUpgradeList();
            } else if (screenId === 'game-over-menu') {
                gameOverMenu.style.display = 'block';
            } else if (screenId === 'pause-menu') {
                pauseMenu.style.display = 'block';
                gamePaused = true;
            } else if (screenId === 'game') {
                uiOverlay.style.display = 'block';
                gameRunning = true;
                lastTime = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            currentScreen = screenId;
        }

        function populateUpgradeList() {
            currentMoneyDisplay.textContent = `金錢：${playerMoney}`;
            upgradeListDiv.innerHTML = '';

            for (const key in UPGRADES_DEFINITION) {
                const def = UPGRADES_DEFINITION[key];
                const currentLevel = playerUpgradeLevels[key] || 0;
                const nextLevel = currentLevel + 1;
                let currentValue, nextValue;
                let nextPrice = Math.round(def.initialPrice * Math.pow(def.priceFactor, currentLevel));

                if (def.type === 'multiply') {
                    currentValue = def.baseValue * Math.pow(def.increment, currentLevel);
                    nextValue = def.baseValue * Math.pow(def.increment, nextLevel);
                } else {
                    currentValue = def.baseValue + def.increment * currentLevel;
                    nextValue = def.baseValue + def.increment * nextLevel;
                }

                const itemDiv = document.createElement('div');
                itemDiv.classList.add('upgrade-item');
                itemDiv.innerHTML = `<h4>${def.category}</h4><h3>${def.name}</h3><p>${def.effect}</p><p class="level-info">等級: ${currentLevel}</p><p>當前: ${def.type === 'multiply' ? currentValue.toFixed(2) : currentValue.toFixed(0)}</p><p>下級: ${def.type === 'multiply' ? nextValue.toFixed(2) : nextValue.toFixed(0)}</p><p class="cost-info">價格: ${nextPrice} 金</p><button data-upgrade-key="${key}" data-price="${nextPrice}">購買</button>`;
                const buyButton = itemDiv.querySelector('button');
                if (playerMoney < nextPrice) {
                    buyButton.disabled = true;
                    buyButton.textContent = '金錢不足';
                } else {
                    buyButton.onclick = () => buyUpgrade(key, nextPrice);
                }
                upgradeListDiv.appendChild(itemDiv);
            }
        }

        function buyUpgrade(key, price) {
            if (playerMoney >= price) {
                playerMoney -= price;
                playerUpgradeLevels[key]++;
                saveGame();
                populateUpgradeList();
            }
        }

        function updatePlayerStatsFromUpgrades() {
            if (!player) return;

            // RESET ALL PLAYER STATS TO THEIR BASE VALUES FIRST
            player.maxHealth = PLAYER_MAX_HEALTH_BASE;
            player.healthRegen = PLAYER_HEALTH_REGEN_BASE;
            player.moveSpeed = PLAYER_MOVE_SPEED_BASE;
            player.baseBulletDamage = PLAYER_BULLET_DAMAGE_BASE;
            player.fireRate = PLAYER_FIRE_RATE_BASE;
            player.bulletsPerShot = PLAYER_BULLETS_PER_SHOT_BASE;

            player.skillQ.damage = SKILL_Q_DAMAGE_BASE;
            player.skillQ.targets = SKILL_Q_TARGETS_BASE;
            player.skillE.damage = SKILL_E_DAMAGE_BASE;
            player.skillE.radius = SKILL_E_RADIUS_BASE;
            player.skillE.knockback = SKILL_E_KNOCKBACK_BASE;
            
            // Laser specific BASE resets
            player.skillRMB.damagePerFrame = SKILL_RMB_DAMAGE_BASE;
            player.skillRMB.maxCharge = PLAYER_LASER_MAX_CHARGE_BASE; 
            player.laserChargeRegen = PLAYER_LASER_CHARGE_REGEN_RATE_BASE; 

            // THEN APPLY UPGRADES
            for (const key in playerUpgradeLevels) {
                const level = playerUpgradeLevels[key];
                if (level <= 0) continue; 
                
                const def = UPGRADES_DEFINITION[key]; 
                
                if (def.type === 'multiply') {
                     const multiplier = Math.pow(def.increment, level);
                     if (key === 'fireRate') player.fireRate *= multiplier;
                } else {
                    const addedValue = def.increment * level;
                    if (key === 'bulletDamage') player.baseBulletDamage += addedValue;
                    else if (key === 'bulletsPerShot') player.bulletsPerShot += addedValue;
                    else if (key === 'maxHealth') player.maxHealth += addedValue;
                    else if (key === 'healthRegen') player.healthRegen += addedValue;
                    else if (key === 'moveSpeed') player.moveSpeed += addedValue;
                    else if (key === 'waveRadius') player.skillE.radius += addedValue;
                    else if (key === 'waveDamage') player.skillE.damage += addedValue;
                    else if (key === 'waveKnockback') player.skillE.knockback += addedValue;
                    else if (key === 'lightningTargets') player.skillQ.targets += addedValue;
                    else if (key === 'lightningDamage') player.skillQ.damage += addedValue;
                    else if (key === 'laserMaxCharge') player.skillRMB.maxCharge += addedValue; 
                    else if (key === 'laserChargeRegen') player.laserChargeRegen += addedValue; 
                    else if (key === 'laserDamage') player.skillRMB.damagePerFrame += addedValue;
                }
            }
            
            // IMPORTANT: Set current health and laser charge AFTER all upgrades are applied
            player.health = player.maxHealth; 
            player.laserCharge = player.skillRMB.maxCharge; 
        }

        function updateHUD() {
            scoreDisplay.textContent = `分數：${currentScore}`;
            if (isBossWave && boss) {
                waveDisplay.textContent = `BOSS WAVE：${currentWave} | BOSS 生命: ${Math.max(0, Math.round(boss.health))}`;
            } else {
                waveDisplay.textContent = `WAVE：${currentWave} | 剩餘敵人：${enemiesInWave - enemiesSpawnedThisWave + enemies.length}`;
            }
            healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
            healthBar.style.backgroundColor = player.health <= 0 ? '#FF00FF' : COLOR_PLAYER;

            // Update laser charge bar
            laserChargeBar.style.width = `${(player.laserCharge / player.skillRMB.maxCharge) * 100}%`;

            updateSkillIcon(skillQIcon, player.skillQ.cooldownLeft, SKILL_Q_COOLDOWN);
            updateSkillIcon(skillEIcon, player.skillE.cooldownLeft, SKILL_E_COOLDOWN);
            
            // RMB icon state management: simply show "ready" if there's any charge, and no cooldown overlay
            if (player.laserCharge > 0) {
                 skillRMBIcon.classList.add('ready');
            } else {
                skillRMBIcon.classList.remove('ready');
            }
            skillRMBIcon.querySelector('.skill-cooldown').style.display = 'none'; // Never show countdown for RMB
        }

        function updateSkillIcon(iconElement, cooldownLeft, totalCooldown) {
            const cooldownDisplay = iconElement.querySelector('.skill-cooldown');
            // This function is for Q and E specific. RMB handles its own display in updateHUD().
            if (iconElement.id === 'skill-q' || iconElement.id === 'skill-e') {
                if (cooldownLeft > 0) {
                    iconElement.classList.remove('ready');
                    cooldownDisplay.style.display = 'flex';
                    cooldownDisplay.textContent = Math.ceil(cooldownLeft);
                } else {
                    iconElement.classList.add('ready');
                    cooldownDisplay.style.display = 'none';
                }
            }
        }

        // === Game Entity Classes ===

        class Player {
            constructor() {
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT / 2;
                this.radius = 15;
                this.color = COLOR_PLAYER;
                
                // Base player stats (will be overridden by upgrades later)
                this.health = PLAYER_MAX_HEALTH_BASE;
                this.maxHealth = PLAYER_MAX_HEALTH_BASE;
                this.healthRegen = PLAYER_HEALTH_REGEN_BASE;
                this.moveSpeed = PLAYER_MOVE_SPEED_BASE;
                this.baseBulletDamage = PLAYER_BULLET_DAMAGE_BASE;
                this.fireRate = PLAYER_FIRE_RATE_BASE;
                this.bulletsPerShot = PLAYER_BULLETS_PER_SHOT_BASE;
                this.lastShotTime = 0;

                this.skillQ = { cooldownLeft: 0, damage: SKILL_Q_DAMAGE_BASE, targets: SKILL_Q_TARGETS_BASE, lastUsed: 0 };
                this.skillE = { cooldownLeft: 0, damage: SKILL_E_DAMAGE_BASE, radius: SKILL_E_RADIUS_BASE, knockback: SKILL_E_KNOCKBACK_BASE, lastUsed: 0 };
                
                // Laser (RMB) skill properties - these base values are used
                // before updatePlayerStatsFromUpgrades applies upgrade levels
                this.skillRMB = { 
                    damagePerFrame: SKILL_RMB_DAMAGE_BASE, 
                    isActive: false, 
                    maxCharge: PLAYER_LASER_MAX_CHARGE_BASE 
                };
                this.laserCharge = PLAYER_LASER_MAX_CHARGE_BASE; 
                this.laserChargeDrainRate = PLAYER_LASER_DRAIN_PER_SECOND_BASE; 
                this.laserChargeRegen = PLAYER_LASER_CHARGE_REGEN_RATE_BASE; 

                this.isDead = false;
                this.activeLaserEffect = null; // Visual laser effect object
            }

            update(deltaTime) {
                if (this.isDead) return;

                // --- Movement ---
                let dx = 0;
                let dy = 0;
                if (keys['w']) dy -= 1;
                if (keys['s']) dy += 1;
                if (keys['a']) dx -= 1;
                if (keys['d']) dx += 1;

                if (dx !== 0 || dy !== 0) {
                    const angle = Math.atan2(dy, dx);
                    this.x += Math.cos(angle) * this.moveSpeed * deltaTime;
                    this.y += Math.sin(angle) * this.moveSpeed * deltaTime;
                }

                // Clamp player within canvas bounds
                this.x = clamp(this.x, this.radius, CANVAS_WIDTH - this.radius);
                this.y = clamp(this.y, this.radius, CANVAS_HEIGHT - this.radius);

                // --- Aiming (from player center to mouse) ---
                this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);

                // --- Basic Shooting ---
                if (mouse.leftPressed && (performance.now() - this.lastShotTime) > (1000 / this.fireRate)) {
                    const numBullets = this.bulletsPerShot;
                    const totalSpreadAngle = Math.PI / 8;
                    const angleStep = numBullets > 1 ? totalSpreadAngle / (numBullets - 1) : 0;
                    const startAngleOffset = numBullets > 1 ? -totalSpreadAngle / 2 : 0;
                    for (let i = 0; i < numBullets; i++) {
                        const currentBulletAngle = this.angle + startAngleOffset + (angleStep * i);
                        // Bullet originates from the tip of the ship, aligned with aiming direction
                        const bulletX = this.x + Math.cos(currentBulletAngle) * this.radius;
                        const bulletY = this.y + Math.sin(currentBulletAngle) * this.radius;
                        const bullet = pool.getProjectile(); 
                        bullet.reset(bulletX, bulletY, Math.cos(currentBulletAngle), Math.sin(currentBulletAngle), BULLET_SPEED, this.baseBulletDamage, 'player');
                        playerProjectiles.push(bullet);
                    }
                    this.lastShotTime = performance.now();
                }

                // --- Skill Cooldowns (Q and E) ---
                // Q skill activation
                if (keys['q'] && this.skillQ.cooldownLeft <= 0) {
                    this.activateSkillQ();
                    keys['q'] = false; // Reset key state after activation
                }
                // E skill activation
                if (keys['e'] && this.skillE.cooldownLeft <= 0) {
                    this.activateSkillE();
                    keys['e'] = false; // Reset key state after activation
                }
                
                // Calculate cooldowns (these are correctly done after potential activation)
                this.skillQ.cooldownLeft = Math.max(0, SKILL_Q_COOLDOWN - (performance.now() - this.skillQ.lastUsed) / 1000);
                this.skillE.cooldownLeft = Math.max(0, SKILL_E_COOLDOWN - (performance.now() - this.skillE.lastUsed) / 1000);
                
                // --- Laser Beam (RMB) Logic ---
                if (mouse.rightPressed && this.laserCharge > 0) { 
                    this.skillRMB.isActive = true;
                    this.laserCharge = Math.max(0, this.laserCharge - this.laserChargeDrainRate * deltaTime); // Drain per second
                    
                    // Screen shake when laser active
                    canvas.style.transform = `translate(${Math.random() * 3 - 1.5}px, ${Math.random() * 3 - 1.5}px)`;
                    
                    // Create/update visual laser effect
                    if (!this.activeLaserEffect) {
                         this.activeLaserEffect = new LaserEffect(0,0,0,0, COLOR_SKILL_RMB, 10, 1);
                    }
                    
                    // Calculate laser path: starts from player's nose, passes through mouse, extends far.
                    const muzzleX = this.x + Math.cos(this.angle) * this.radius;
                    const muzzleY = this.y + Math.sin(this.angle) * this.radius;

                    const vectorToMouseX = mouse.x - muzzleX;
                    const vectorToMouseY = mouse.y - muzzleY;
                    const distToMouse = dist(muzzleX, muzzleY, mouse.x, mouse.y);
                    
                    // Extend far enough to pass beyond the edge of the screen, even if aiming directly at player/close to muzzle.
                    // Adjust extendFactor for edge cases where mouse is very close to muzzle or direct vertical/horizontal.
                    const minExtendDistance = Math.sqrt(CANVAS_WIDTH**2 + CANVAS_HEIGHT**2); // Diagonal distance
                    let currentExtendFactor = (distToMouse > 0) ? (minExtendDistance / distToMouse) * 1.2 : 2; // Add safety buffer and default if distToMouse is zero
                    
                    const farX = muzzleX + vectorToMouseX * currentExtendFactor;
                    const farY = muzzleY + vectorToMouseY * currentExtendFactor;

                    this.activeLaserEffect.x1 = muzzleX;
                    this.activeLaserEffect.y1 = muzzleY;
                    this.activeLaserEffect.x2 = farX;
                    this.activeLaserEffect.y2 = farY;


                    // Apply continuous damage to targets caught in the laser
                    const laserX1 = this.activeLaserEffect.x1;
                    const laserY1 = this.activeLaserEffect.y1;
                    const laserX2 = this.activeLaserEffect.x2;
                    const laserY2 = this.activeLaserEffect.y2;
                    const lineLengthSq = (laserX2 - laserX1)**2 + (laserY2 - laserY1)**2;

                    const targetsForLaserDamage = [];
                    if (isBossWave) {
                        if (boss && !boss.isDead) targetsForLaserDamage.push(boss);
                    } else {
                        targetsForLaserDamage.push(...enemies); 
                    }

                    for (let i = targetsForLaserDamage.length - 1; i >= 0; i--) {
                        const target = targetsForLaserDamage[i];
                        if (!target || !target.isActive) continue;

                        let radius;
                        if (target instanceof Boss) radius = target.width / 2; 
                        else radius = target.radius;

                        let t = ((target.x - laserX1) * (laserX2 - laserX1) + (target.y - laserY1) * (laserY2 - laserY1)) / lineLengthSq;
                        t = Math.max(0, Math.min(1, t));
                        const closestX = laserX1 + t * (laserX2 - laserX1);
                        const closestY = laserY1 + t * (laserY2 - laserY1);

                        if (dist(closestX, closestY, target.x, target.y) < radius + this.activeLaserEffect.width / 2) {
                            target.takeDamage(this.skillRMB.damagePerFrame * deltaTime * 60); // Apply damage scaled by FPS
                        }
                    }

                } else { // Right click released OR laserCharge is 0
                    this.skillRMB.isActive = false;
                    this.activeLaserEffect = null;
                    if (!mouse.rightPressed) { 
                        canvas.style.transform = ''; // Reset screen shake only if button actually released
                    }

                    // Recharge logic: only if NOT actively firing laser AND right mouse button is NOT pressed AND not at max charge
                    if (!this.skillRMB.isActive && !mouse.rightPressed && this.laserCharge < this.skillRMB.maxCharge) { 
                        this.laserCharge += this.laserChargeRegen * deltaTime; // Regen per second
                        this.laserCharge = clamp(this.laserCharge, 0, this.skillRMB.maxCharge);
                    }
                }
                
                // No specific cooldownLeft for RMB beyond current charge
                this.skillRMB.cooldownLeft = 0;


                // --- Health Regeneration ---
                this.health = clamp(this.health + this.healthRegen * deltaTime, -Infinity, this.maxHealth);

                // --- Game Over ---
                if (this.health <= 0 && !this.isDead) { this.isDead = true; endGame(); }
            }

            draw(ctx) {
                if (this.isDead) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                // Player body (triangle/ship shape)
                ctx.beginPath();
                ctx.moveTo(this.radius, 0);
                ctx.lineTo(-this.radius, -this.radius / 1.5);
                ctx.lineTo(-this.radius, this.radius / 1.5);
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;

                // Engine glow
                ctx.beginPath();
                ctx.arc(-this.radius * 1.2, 0, this.radius * 0.8, -Math.PI / 2, Math.PI / 2, false);
                ctx.fillStyle = `rgba(0, 255, 255, 0.7)`;
                ctx.shadowBlur = 20;
                ctx.shadowColor = COLOR_PLAYER;
                ctx.fill();
                ctx.shadowBlur = 0;

                for (let i = 0; i < 2; i++) {
                    const particle = pool.getParticle();
                    particle.reset(this.x + Math.cos(this.angle + Math.PI) * this.radius * 1.2, this.y + Math.sin(this.angle + Math.PI) * this.radius * 1.2 + (i === 0 ? -this.radius / 3 : this.radius / 3), Math.cos(this.angle + Math.PI + (Math.random() - 0.5) * 0.5) * 100, Math.sin(this.angle + Math.PI + (Math.random() - 0.5) * 0.5) * 100, 2 + Math.random() * 3, 0.5 + Math.random() * 0.5, COLOR_PLAYER, `rgba(0, 255, 255, ${0.5 + Math.random() * 0.5})`);
                    particles.push(particle);
                }
                ctx.restore();
            }

            activateSkillQ() {
                this.skillQ.lastUsed = performance.now();
                const potentialTargets = [...enemies, ...missiles].filter(e => e && !e.isDead && e.isActive); 
                potentialTargets.sort((a, b) => dist(this.x, this.y, a.x, a.y) - dist(this.x, this.y, b.x, b.y));
                let chainedTargets = []; let currentTarget = { x: this.x, y: this.y };
                for (let i = 0; i < this.skillQ.targets && potentialTargets.length > 0; i++) {
                    let nextTarget = null, nearestDist = Infinity, nearestIndex = -1;
                    for (let j = 0; j < potentialTargets.length; j++) {
                        const d = dist(currentTarget.x, currentTarget.y, potentialTargets[j].x, potentialTargets[j].y);
                        if (d < nearestDist) { nearestDist = d; nextTarget = potentialTargets[j]; nearestIndex = j; }
                    }
                    if (nextTarget) {
                        lightningEffects.push({ x1: currentTarget.x, y1: currentTarget.y, x2: nextTarget.x, y2: nextTarget.y, lifetime: 0.2 });
                        nextTarget.takeDamage(this.skillQ.damage); 
                        chainedTargets.push(nextTarget); currentTarget = nextTarget;
                        potentialTargets.splice(nearestIndex, 1);
                    } else { break; }
                }
            }

            activateSkillE() {
                this.skillE.lastUsed = performance.now();
                waveEffects.push({ 
                    x: this.x, 
                    y: this.y, 
                    radius: 0, 
                    maxRadius: this.skillE.radius, 
                    speed: this.skillE.radius / 0.3, 
                    alpha: 1,
                    enemiesHit: new Set(),
                    missilesHit: new Set() 
                });
            }
            
            takeDamage(amount) {
                this.health -= amount;
                this.health = clamp(this.health, -Infinity, this.maxHealth);
                canvas.style.transform = `translate(${Math.random() * 5 - 2.5}px, ${Math.random() * 5 - 2.5}px)`;
                setTimeout(() => canvas.style.transform = '', 50);
            }
        }

        class Enemy {
             constructor(type, x, y, hp, speed, radius, color, behavior, scoreValue) {
                this.reset(type, x, y, hp, speed, radius, color, behavior, scoreValue);
            }

            reset(type, x, y, hp, speed, radius, color, behavior, scoreValue) {
                this.type = type; this.x = x; this.y = y; this.initialHealth = hp;
                // Directly use the provided 'hp' value from spawnEnemy, which is pre-scaled and overridden for Brute
                this.health = hp; 
                this.speed = speed; this.radius = radius; this.color = color;
                this.behavior = behavior; this.scoreValue = scoreValue; this.isDead = false;
                this.knockbackVelX = 0; this.knockbackVelY = 0; this.knockbackFriction = 0.9;
                this.oscillationTimer = Math.random() * Math.PI * 2; this.isActive = true;
            }
            update(deltaTime) {
                if (this.isDead) return;
                this.x += this.knockbackVelX * deltaTime; this.y += this.knockbackVelY * deltaTime;
                this.knockbackVelX *= this.knockbackFriction; this.knockbackVelY *= this.knockbackFriction;
                if (Math.abs(this.knockbackVelX) < 1) this.knockbackVelX = 0;
                if (Math.abs(this.knockbackVelY) < 1) this.knockbackVelY = 0;
                const dx = player.x - this.x; const dy = player.y - this.y;
                const angle = Math.atan2(dy, dx);
                let moveX = Math.cos(angle) * this.speed; let moveY = Math.sin(angle) * this.speed;
                if (this.behavior === 'chase_oscillate') {
                    this.oscillationTimer += deltaTime * 5; const oscillationOffset = Math.sin(this.oscillationTimer) * 50;
                    const perpAngle = angle + Math.PI / 2;
                    moveX += Math.cos(perpAngle) * oscillationOffset; moveY += Math.sin(perpAngle) * oscillationOffset;
                }
                this.x += moveX * deltaTime; this.y += moveY * deltaTime;
            }
            draw(ctx) {
                if (this.isDead) return;
                ctx.beginPath();
                if (this.type === 'Grunt' || this.type === 'Spitter') { ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); }
                else if (this.type === 'Scout') {
                    ctx.save(); ctx.translate(this.x, this.y); const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    ctx.rotate(angle); ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius / 2, -this.radius * 0.866);
                    ctx.lineTo(-this.radius / 2, this.radius * 0.866); ctx.closePath(); ctx.restore();
                } else if (this.type === 'Brute') { ctx.rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); }
                ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.fill();
                if (this.health < this.initialHealth) {
                    const healthBarWidth = this.radius * 2; const healthBarHeight = 3;
                    const healthBarX = this.x - this.radius; const healthBarY = this.y - this.radius - 10;
                    ctx.fillStyle = `rgba(255, 0, 255, 0.4)`; ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                    ctx.fillStyle = `rgba(0, 255, 255, 0.8)`; ctx.fillRect(healthBarX, healthBarY, healthBarWidth * (this.health / this.initialHealth), healthBarHeight);
                }
                ctx.shadowBlur = 0;
            }
            takeDamage(amount) {
                if (this.isDead) return; this.health -= amount;
                if (this.health <= 0) {
                    this.isDead = true; this.isActive = false; currentScore += this.scoreValue;
                    this.explode();
                }
            }
            applyKnockback(vx, vy) { this.knockbackVelX += vx; this.knockbackVelY += vy; }
            explode() {
                const numParticles = 20 + Math.random() * 10;
                for (let i = 0; i < numParticles; i++) {
                    const particle = pool.getParticle();
                    const angle = Math.random() * Math.PI * 2; const speed = 100 + Math.random() * 300;
                    const size = 3 + Math.random() * 5; const lifetime = 0.5 + Math.random() * 0.5;
                    const color = COLOR_EXPLOSION_PARTICLE[Math.floor(Math.random() * COLOR_EXPLOSION_PARTICLE.length)];
                    particle.reset(this.x, this.y, Math.cos(angle) * speed, Math.sin(angle) * speed, size, lifetime, color, color);
                    particles.push(particle);
                }
                if (this.type === 'Brute') {
                    canvas.style.transform = `translate(${Math.random() * 8 - 4}px, ${Math.random() * 8 - 4}px)`;
                    setTimeout(() => canvas.style.transform = '', 70);
                }
            }
        }
        
        class Boss {
            constructor() {
                this.x = CANVAS_WIDTH / 2;
                this.y = -150; 
                this.targetY = 150;
                this.width = 400;
                this.height = 120;
                this.health = BOSS_HEALTH_BASE * (1 + (currentWave / BOSS_WAVE_INTERVAL - 1) * 0.5); 
                this.initialHealth = this.health;
                this.speed = BOSS_SPEED;
                this.moveDirection = 1; 
                this.isDead = false;
                this.isActive = true;
                this.lastMissileFireTime = 0;
                this.scoreValue = BOSS_SCORE_VALUE * (currentWave / BOSS_WAVE_INTERVAL);
                this.weaponPods = [
                    { x: -this.width / 3, y: this.height / 2 - 10 }, 
                    { x: this.width / 3, y: this.height / 2 - 10 }
                ];
                this.shieldFlashTimer = 0; 
            }

            update(deltaTime) {
                if (this.isDead) return;

                if (this.y < this.targetY) {
                    this.y += 100 * deltaTime; 
                    return; 
                }
                
                this.x += this.speed * this.moveDirection * deltaTime;
                if (this.x + this.width / 2 > CANVAS_WIDTH || this.x - this.width / 2 < 0) {
                    this.moveDirection *= -1;
                    this.x = clamp(this.x, this.width / 2, CANVAS_WIDTH - this.width / 2);
                }

                if (performance.now() - this.lastMissileFireTime > 1000 / BOSS_MISSILE_FIRE_RATE) {
                    this.fireMissile();
                    this.lastMissileFireTime = performance.now();
                }

                // Update shield flash timer
                if (this.shieldFlashTimer > 0) {
                    this.shieldFlashTimer -= deltaTime * 1000;
                    if (this.shieldFlashTimer < 0) this.shieldFlashTimer = 0;
                }
            }

            fireMissile() {
                const pod = this.weaponPods[Math.floor(Math.random() * this.weaponPods.length)]; 
                
                const newMissile = pool.getMissile(); 
                newMissile.reset(this.x + pod.x, this.y + pod.y);
                missiles.push(newMissile);
            }
            
            draw(ctx) {
                if (!this.isActive) return;
                
                // Main Body 
                ctx.fillStyle = COLOR_BOSS_BODY;
                ctx.shadowColor = COLOR_BOSS_CORE;
                ctx.shadowBlur = 20;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);

                // Armor plates / Details
                ctx.fillStyle = COLOR_BOSS_ARMOR;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height * 0.2);
                ctx.fillRect(this.x - this.width / 2, this.y + this.height / 2 - this.height * 0.2, this.width, this.height * 0.2);
                ctx.fillRect(this.x - this.width / 2 + 20, this.y - 10, this.width - 40, 20);

                // Core 
                const coreRadius = 25 + Math.sin(performance.now() / 300) * 5; // Pulsating effect
                ctx.beginPath();
                ctx.arc(this.x, this.y, coreRadius, 0, Math.PI * 2);
                ctx.fillStyle = COLOR_BOSS_CORE;
                ctx.fill();
                
                // Weapon Pods 
                this.weaponPods.forEach(pod => {
                    ctx.fillStyle = COLOR_BOSS_ARMOR;
                    ctx.beginPath();
                    ctx.fillRect(this.x + pod.x - 15, this.y + pod.y - 15, 30, 30);
                    ctx.fillStyle = COLOR_MISSILE_TRAIL;
                    ctx.fillRect(this.x + pod.x - 5, this.y + pod.y + 15, 10, 10);
                });
                
                // Draw shield flash effect if active
                if (this.shieldFlashTimer > 0) {
                    ctx.save();
                    const flashAlpha = clamp(this.shieldFlashTimer / BOSS_SHIELD_FLASH_DURATION * 0.6, 0, 0.6); 
                    ctx.globalAlpha = flashAlpha;
                    ctx.strokeStyle = COLOR_BOSS_SHIELD_FLASH;
                    ctx.lineWidth = 5; 
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = COLOR_BOSS_SHIELD_FLASH;
                    
                    ctx.beginPath();
                    ctx.rect(this.x - this.width / 2 - 5, this.y - this.height / 2 - 5, this.width + 10, this.height + 10);
                    ctx.stroke();

                    ctx.restore();
                }
                
                ctx.shadowBlur = 0; 

                // Health bar
                const healthBarWidth = this.width;
                const healthBarHeight = 10;
                const healthBarX = this.x - this.width / 2;
                const healthBarY = this.y - this.height / 2 - 25; 
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)'; 
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                ctx.fillStyle = 'rgba(255, 0, 0, 1)'; 
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth * (this.health / this.initialHealth), healthBarHeight);
            }

            takeDamage(amount) { // This method is for skill damage only
                if (this.isDead) return;
                this.health -= amount;
                canvas.style.transform = `translate(${Math.random() * 8 - 4}px, ${Math.random() * 8 - 4}px)`;
                setTimeout(() => canvas.style.transform = '', 70);

                if (this.health <= 0) {
                    this.isDead = true;
                    this.isActive = false;
                    currentScore += this.scoreValue;
                    this.explode();
                }
            }
            
            // Method for regular bullet hits
            takeBulletHit(hitX, hitY) {
                // BOSS takes no damage from regular bullets, but flashes shield
                this.shieldFlashTimer = BOSS_SHIELD_FLASH_DURATION; 
                
                // Generate a "shield particle" at the hit location
                const particle = pool.getParticle();
                particle.reset(hitX, hitY, (Math.random() - 0.5) * 50, (Math.random() - 0.5) * 50, 
                               10 + Math.random() * 5, 0.2, COLOR_PLAYER_BULLET, COLOR_BOSS_SHIELD_FLASH);
                particles.push(particle);
            }

            explode() {
                const numParticles = 200; 
                for (let i = 0; i < numParticles; i++) {
                    const particle = pool.getParticle(); 
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 200 + Math.random() * 600;
                    const size = 5 + Math.random() * 10;
                    const lifetime = 1 + Math.random() * 1.5;
                    const color = COLOR_EXPLOSION_PARTICLE[Math.floor(Math.random() * COLOR_EXPLOSION_PARTICLE.length)];
                    const spawnX = this.x + (Math.random() - 0.5) * this.width;
                    const spawnY = this.y + (Math.random() - 0.5) * this.height;
                    particle.reset(spawnX, spawnY, Math.cos(angle) * speed, Math.sin(angle) * speed, size, lifetime, color, color);
                    particles.push(particle);
                }
                canvas.style.transform = `translate(${Math.random() * 15 - 7.5}px, ${Math.random() * 15 - 7.5}px)`;
                setTimeout(() => canvas.style.transform = '', 150);
            }
        }

        class Missile {
            constructor() { 
                this.reset(0, 0); 
            }

            reset(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 8;
                this.speed = MISSILE_SPEED;
                this.angle = -Math.PI / 2; 
                this.isActive = true;
                this.isDead = false; 
            }

            update(deltaTime) {
                if (!this.isActive) return;
                if (player && !player.isDead) {
                    const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
                    let angleDiff = targetAngle - this.angle;
                    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    this.angle += clamp(angleDiff, -MISSILE_TURN_RATE * deltaTime, MISSILE_TURN_RATE * deltaTime);
                }

                this.x += Math.cos(this.angle) * this.speed * deltaTime;
                this.y += Math.sin(this.angle) * this.speed * deltaTime;

                const particle = pool.getParticle(); 
                const trailAngle = this.angle + Math.PI + (Math.random() - 0.5) * 0.8; 
                particle.reset(this.x, this.y, Math.cos(trailAngle) * 50, Math.sin(trailAngle) * 50, 
                               5 + Math.random() * 3, 0.4, COLOR_MISSILE_TRAIL, COLOR_MISSILE_TRAIL);
                particles.push(particle);

                if (this.x < -100 || this.x > CANVAS_WIDTH + 100 || this.y < -100 || this.y > CANVAS_HEIGHT + 100) {
                    this.isActive = false;
                }
            }

            draw(ctx) {
                if (!this.isActive) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.beginPath();
                ctx.moveTo(this.radius * 1.5, 0); 
                ctx.lineTo(-this.radius, -this.radius / 2); 
                ctx.lineTo(-this.radius, this.radius / 2); 
                ctx.closePath();
                ctx.fillStyle = COLOR_MISSILE;
                ctx.shadowColor = COLOR_MISSILE;
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.restore();
                ctx.shadowBlur = 0;
            }

            takeDamage(amount) { 
                if (!this.isActive) return;
                this.isActive = false;
                this.isDead = true; 
                this.explode();
            }

            explode() {
                const numParticles = 15;
                for (let i = 0; i < numParticles; i++) {
                    const particle = pool.getParticle(); 
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 150;
                    const size = 2 + Math.random() * 3;
                    const lifetime = 0.3 + Math.random() * 0.4;
                    particle.reset(this.x, this.y, Math.cos(angle) * speed, Math.sin(angle) * speed, size, lifetime, COLOR_MISSILE, COLOR_MISSILE);
                    particles.push(particle);
                }
            }
        }

        class Projectile {
             constructor() {
                this.reset(0, 0, 0, 0, 0, 0, ''); 
            }
            
            reset(x, y, velX, velY, speed, damage, owner) {
                this.x = x; this.y = y;
                this.velX = velX * speed; this.velY = velY * speed;
                this.damage = damage; this.radius = 5;
                this.color = (owner === 'player') ? COLOR_PLAYER_BULLET : COLOR_ENEMY_GRUNT;
                this.owner = owner; this.isActive = true;
            }

            update(deltaTime) {
                if (!this.isActive) return;
                this.x += this.velX * deltaTime; this.y += this.velY * deltaTime;
                if (this.x < -this.radius || this.x > CANVAS_WIDTH + this.radius || this.y < -this.radius || this.y > CANVAS_HEIGHT + this.radius) {
                    this.isActive = false;
                }
            }
            draw(ctx) {
                if (!this.isActive) return;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.fill(); ctx.shadowBlur = 0;
                if (this.owner === 'player') {
                    const particle = pool.getParticle(); 
                    particle.reset(this.x - this.velX * deltaTime * 5, this.y - this.velY * deltaTime * 5, -this.velX * 0.1, -this.velY * 0.1, 2 + Math.random() * 2, 0.2 + Math.random() * 0.2, COLOR_PLAYER, `rgba(0, 255, 255, ${0.4 + Math.random() * 0.4})`);
                    particles.push(particle);
                }
            }
        }

        class Particle {
            constructor() {
                this.reset(0, 0, 0, 0, 0, 0, '', ''); 
            }

            reset(x, y, velX, velY, size, lifetime, color, glowColor) {
                this.x = x; this.y = y; this.velX = velX; this.velY = velY;
                this.size = size; this.lifetime = lifetime; this.timeAlive = 0;
                this.color = color; this.glowColor = glowColor || color; this.isActive = true;
            }
            update(deltaTime) {
                if (!this.isActive) return;
                this.x += this.velX * deltaTime; this.y += this.velY * deltaTime;
                this.timeAlive += deltaTime;
                if (this.timeAlive >= this.lifetime) this.isActive = false;
            }
            draw(ctx) {
                if (!this.isActive) return;
                const alpha = 1 - (this.timeAlive / this.lifetime);
                ctx.globalAlpha = alpha; ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = this.glowColor; ctx.fill();
                ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1;
            }
        }

        class LaserEffect {
             constructor(x1, y1, x2, y2, color, width, alpha) {
                this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
                this.color = color; this.width = width; this.alpha = alpha;
            }
            draw(ctx) {
                ctx.globalAlpha = this.alpha; ctx.beginPath(); ctx.moveTo(this.x1, this.y1);
                ctx.lineTo(this.x2, this.y2); ctx.strokeStyle = this.color; ctx.lineWidth = this.width;
                ctx.shadowBlur = 20; ctx.shadowColor = this.color; ctx.stroke();
                ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = this.width * 0.4;
                ctx.shadowBlur = 0; ctx.stroke(); ctx.globalAlpha = 1;
            }
        }

        // --- Background Stars ---
        const stars = [];
        let playerPrevX = CANVAS_WIDTH / 2, playerPrevY = CANVAS_HEIGHT / 2;
        function createStars() { for (let i = 0; i < 400; i++) { stars.push({ x: Math.random() * CANVAS_WIDTH, y: Math.random() * CANVAS_HEIGHT, size: Math.random() * 2, layer: Math.floor(Math.random() * 3) }); } }
        function drawStars(ctx) {
            const dx = player.x - playerPrevX; const dy = player.y - playerPrevY;
            ctx.fillStyle = '#FFFFFF';
            for (const star of stars) {
                let parallaxSpeed, alphaMultiplier;
                switch (star.layer) {
                    case 0: parallaxSpeed = 0.05; alphaMultiplier = 0.4; break;
                    case 1: parallaxSpeed = 0.15; alphaMultiplier = 0.6; break;
                    case 2: parallaxSpeed = 0.3; alphaMultiplier = 0.8; break;
                }
                star.x -= dx * parallaxSpeed; star.y -= dy * parallaxSpeed;
                if (star.x < 0) star.x += CANVAS_WIDTH; if (star.x > CANVAS_WIDTH) star.x -= CANVAS_WIDTH;
                if (star.y < 0) star.y += CANVAS_HEIGHT; if (star.y > CANVAS_HEIGHT) star.y -= CANVAS_HEIGHT;
                ctx.globalAlpha = star.size / 2 * alphaMultiplier;
                ctx.beginPath(); ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2); ctx.fill();
            }
            ctx.globalAlpha = 1; playerPrevX = player.x; playerPrevY = player.y;
        }

        function drawCrosshair(ctx) {
            const size = 20, gap = 5, thickness = 2;
            ctx.strokeStyle = COLOR_CROSSHAIR; ctx.lineWidth = thickness;
            ctx.shadowBlur = 10; ctx.shadowColor = COLOR_CROSSHAIR;
            ctx.beginPath(); ctx.moveTo(mouse.x - size - gap, mouse.y); ctx.lineTo(mouse.x - gap, mouse.y);
            ctx.moveTo(mouse.x + gap, mouse.y); ctx.lineTo(mouse.x + size + gap, mouse.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(mouse.x, mouse.y - size - gap); ctx.lineTo(mouse.x, mouse.y - gap);
            ctx.moveTo(mouse.x, mouse.y + gap); ctx.lineTo(mouse.x, mouse.y + size + gap); ctx.stroke();
            ctx.beginPath(); ctx.arc(mouse.x, mouse.y, thickness * 1.5, 0, Math.PI * 2);
            ctx.fillStyle = COLOR_CROSSHAIR; ctx.fill(); ctx.shadowBlur = 0;
        }

        // === Game Logic Functions ===

        function initGame() {
            canvas = document.getElementById('gameCanvas'); ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH; canvas.height = CANVAS_HEIGHT;
            loadGame(); showScreen('main-menu');
            startGameBtn.addEventListener('click', startGame);
            upgradesBtn.addEventListener('click', () => showScreen('upgrade-screen'));
            backFromUpgradesBtn.addEventListener('click', () => showScreen('main-menu'));
            returnToMainMenuBtn.addEventListener('click', () => showScreen('main-menu'));
            resumeGameBtn.addEventListener('click', resumeGame);
            exitGameBtn.addEventListener('click', endGame);
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true; // Mark key as currently held down
                
                // Pause game on 'p' or 'escape'
                if (key === 'p' || key === 'escape') {
                    if (gameRunning && !player.isDead) { 
                        if (gamePaused) resumeGame(); 
                        else pauseGame(); 
                    }
                }
            });
            document.addEventListener('keyup', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = false; // Mark key as released
            });

            canvas.addEventListener('mousemove', (e) => { const rect = canvas.getBoundingClientRect(); mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top; });
            canvas.addEventListener('mousedown', (e) => { if (e.button === 0) mouse.leftPressed = true; if (e.button === 2) mouse.rightPressed = true; });
            canvas.addEventListener('mouseup', (e) => { 
                if (e.button === 0) mouse.leftPressed = false; 
                if (e.button === 2) { 
                    mouse.rightPressed = false;
                    canvas.style.transform = ''; // Reset screen shake after releasing RMB
                } 
            });
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            createStars();
        }

        function startGame() {
            player = new Player();
            updatePlayerStatsFromUpgrades(); 
            
            enemies = []; 
            missiles = [];
            boss = null;

            playerProjectiles = []; 
            particles = [];
            lightningEffects = []; 
            waveEffects = [];
            player.activeLaserEffect = null;

            currentScore = 0; 
            currentWave = 0; 
            enemiesSpawnedThisWave = 0;
            lastEnemySpawnTime = 0; 
            waveTextDisplayTime = performance.now();
            playerPrevX = player.x; 
            playerPrevY = player.y;
            startNextWave();
            showScreen('game');
        }

        function endGame() {
            if (!gameRunning && !gamePaused) return;
            gameRunning = false; gamePaused = false;
            cancelAnimationFrame(animationFrameId);
            playerMoney += currentScore;
            if (currentScore > highScore) { highScore = currentScore; }
            saveGame();
            finalScoreDisplay.textContent = currentScore;
            finalWaveDisplay.textContent = currentWave;
            gainedMoneyDisplay.textContent = currentScore;
            showScreen('game-over-menu');
        }

        function pauseGame() { gamePaused = true; cancelAnimationFrame(animationFrameId); showScreen('pause-menu'); }
        function resumeGame() { gamePaused = false; showScreen('game'); }

        function startNextWave() {
            currentWave++;
            enemiesSpawnedThisWave = 0;
            lastEnemySpawnTime = 0;
            waveTextDisplayTime = performance.now();
            
            enemies.forEach(e => e.isDead = true); 
            enemies = []; 
            missiles.forEach(m => m.isActive = false); 
            missiles = []; 
            if (boss) {
                boss.isDead = true; 
                boss = null;
            }

            if (currentWave % BOSS_WAVE_INTERVAL === 0) {
                isBossWave = true;
                boss = new Boss();
                enemiesInWave = 1; 
            } else {
                isBossWave = false;
                boss = null; 
                enemiesInWave = WAVE_INITIAL_ENEMY_COUNT + (currentWave - 1) * WAVE_ENEMY_COUNT_PER_WAVE;
            }
        }

        function spawnEnemy() {
            if (enemiesSpawnedThisWave >= enemiesInWave || isBossWave) return; 
            const enemyChoices = [];
            // The Brute's base HP definition here is just for type matching in 'def'.
            // The actual *effective* base HP of 400 or 2000 is applied below when creating the enemy.
            if (currentWave >= 1) enemyChoices.push({ type: 'Grunt', hp: 15, speed: 120, radius: 10, color: COLOR_ENEMY_GRUNT, behavior: 'chase_oscillate', score: 10 });
            if (currentWave >= 2) enemyChoices.push({ type: 'Scout', hp: 10, speed: 200, radius: 12, color: COLOR_ENEMY_SCOUT, behavior: 'chase_oscillate', score: 15 });
            if (currentWave >= 4) enemyChoices.push({ type: 'Brute', hp: 40, speed: 80, radius: 25, color: COLOR_ENEMY_BRUTE, behavior: 'chase_direct', score: 30 });
            const def = enemyChoices[Math.floor(Math.random() * enemyChoices.length)];
            
            let hp = def.hp; // Get base HP from definition
            if (def.type === 'Brute') {
                hp = 500; // Directly apply the 10x original *new* value for Brute's effective base HP before wave scaling
            }

            hp *= (1 + (currentWave - 1) * WAVE_ENEMY_HP_SCALING); // Apply wave scaling on top of (possibly modified) base HP
            
            let speed = def.speed * (1 + (currentWave - 1) * WAVE_ENEMY_SPEED_SCALING);

            let x, y;
            const side = Math.floor(Math.random() * 4);
            if (side === 0) { x = Math.random() * CANVAS_WIDTH; y = -ENEMY_SPAWN_OFFSET; } 
            else if (side === 1) { x = CANVAS_WIDTH + ENEMY_SPAWN_OFFSET; y = Math.random() * CANVAS_HEIGHT; } 
            else if (side === 2) { x = Math.random() * CANVAS_WIDTH; y = CANVAS_HEIGHT + ENEMY_SPAWN_OFFSET; } 
            else { x = -ENEMY_SPAWN_OFFSET; y = Math.random() * CANVAS_HEIGHT; }
            enemies.push(new Enemy(def.type, x, y, hp, speed, def.radius, def.color, def.behavior, def.score));
            enemiesSpawnedThisWave++;
        }

        function checkCollisions() {
            // Player Projectile vs Enemy/Boss
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const proj = playerProjectiles[i];
                if (!proj.isActive) continue;

                if (isBossWave && boss && !boss.isDead) {
                    if (proj.x > boss.x - boss.width / 2 && proj.x < boss.x + boss.width / 2 && proj.y > boss.y - boss.height / 2 && proj.y < boss.y + boss.height / 2) {
                        boss.takeBulletHit(proj.x, proj.y); 
                        pool.returnProjectile(proj); 
                        playerProjectiles.splice(i, 1); 
                        continue; 
                    }
                } else {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (enemy.isDead) continue;
                        if (dist(proj.x, proj.y, enemy.x, enemy.y) < proj.radius + enemy.radius) {
                            enemy.takeDamage(proj.damage); 
                            pool.returnProjectile(proj); 
                            playerProjectiles.splice(i, 1); 
                            break; 
                        }
                    }
                }
            }

            // Player vs Enemy / Player vs Missile
            if (isBossWave) {
                 for (let i = missiles.length - 1; i >= 0; i--) {
                    const missile = missiles[i];
                    if (!missile.isActive) continue;
                    if (dist(player.x, player.y, missile.x, missile.y) < player.radius + missile.radius) {
                        player.takeDamage(MISSILE_DAMAGE); missile.takeDamage(999); 
                    }
                 }
            } else {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i]; if (enemy.isDead) continue;
                    if (dist(player.x, player.y, enemy.x, enemy.y) < player.radius + enemy.radius) {
                        player.takeDamage(10); enemy.takeDamage(5);
                        const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                        player.x = clamp(player.x + Math.cos(angleToPlayer) * 15, player.radius, CANVAS_WIDTH - player.radius);
                        player.y = clamp(player.y + Math.sin(angleToPlayer) * 15, player.radius, CANVAS_HEIGHT - player.radius);
                    }
                }
            }
            
            // Laser Beam hit effects (damage application handled in Player.update)
            if (player.skillRMB.isActive && player.activeLaserEffect) {
                const { x1, y1, x2, y2 } = player.activeLaserEffect;
                const lineLengthSq = (x2 - x1)**2 + (y2 - y1)**2;
                if (lineLengthSq === 0) return; 

                const targets = [];
                if (isBossWave) {
                    if (boss && !boss.isDead) targets.push(boss);
                    targets.push(...missiles); 
                } else {
                    targets.push(...enemies); 
                }

                for (let i = targets.length - 1; i >= 0; i--) {
                    const target = targets[i]; 
                    if (!target || !target.isActive) continue; 

                    let radius;
                    if (target instanceof Missile) radius = target.radius;
                    else if (target instanceof Boss) radius = target.width / 2; 
                    else radius = target.radius;

                    let t = ((target.x - x1) * (x2 - x1) + (target.y - y1) * (y2 - y1)) / lineLengthSq;
                    t = Math.max(0, Math.min(1, t)); 
                    const closestX = x1 + t * (x2 - x1); 
                    const closestY = y1 + t * (y2 - y1);
                    
                    if (dist(closestX, closestY, target.x, target.y) < radius + player.activeLaserEffect.width / 2) {
                        if (target instanceof Missile) {
                             target.takeDamage(999); 
                        } else if (target instanceof Boss || target instanceof Enemy) { 
                                const numParticles = 2 + Math.random() * 3;
                                for (let k = 0; k < numParticles; k++) {
                                    const particle = pool.getParticle();
                                    const angle = Math.random() * Math.PI * 2;
                                    const speed = 50 + Math.random() * 100;
                                    const size = 3 + Math.random() * 6;
                                    const lifetime = 0.2 + Math.random() * 0.3;
                                    const color = COLOR_SKILL_RMB; 
                                    particle.reset(closestX, closestY, Math.cos(angle) * speed, Math.sin(angle) * speed, size, lifetime, color, color);
                                    particles.push(particle);
                                }
                            }
                    }
                }
            }
        }


        function gameLoop(timestamp) {
            if (!gameRunning || gamePaused) { cancelAnimationFrame(animationFrameId); return; }
            deltaTime = (timestamp - lastTime) / 1000; lastTime = timestamp;

            // --- Update Game State ---
            player.update(deltaTime);

            if (isBossWave) {
                if (boss) boss.update(deltaTime);
                missiles = missiles.filter(m => { 
                    m.update(deltaTime); 
                    if (!m.isActive) pool.returnMissile(m); 
                    return m.isActive; 
                });
            } else {
                enemies = enemies.filter(enemy => { enemy.update(deltaTime); return !enemy.isDead; });
                const spawnInterval = Math.max(WAVE_SPAWN_INTERVAL_MIN, WAVE_SPAWN_INTERVAL_BASE - (currentWave - 1) * WAVE_SPAWN_INTERVAL_DECREASE);
                if (enemiesSpawnedThisWave < enemiesInWave && (performance.now() - lastEnemySpawnTime > spawnInterval)) {
                    spawnEnemy(); lastEnemySpawnTime = performance.now();
                }
            }

            // Check wave completion condition
            if ((isBossWave && boss && boss.isDead) || (!isBossWave && enemies.length === 0 && enemiesSpawnedThisWave >= enemiesInWave)) {
                if (isBossWave && boss) boss = null; 
                startNextWave();
            }

            playerProjectiles = playerProjectiles.filter(proj => { 
                proj.update(deltaTime); 
                if (!proj.isActive) pool.returnProjectile(proj); 
                return proj.isActive; 
            });
            particles = particles.filter(p => { 
                p.update(deltaTime); 
                if (!p.isActive) pool.returnParticle(p); 
                return p.isActive; 
            });

            lightningEffects = lightningEffects.filter(e => { e.lifetime -= deltaTime; return e.lifetime > 0; });
            
            // === Wave Effect (E Skill) Logic - now applies damage based on expansion ===
            waveEffects = waveEffects.filter(e => { 
                const previousRadius = e.radius; 
                e.radius += e.speed * deltaTime; 
                e.alpha = 1 - (e.radius / e.maxRadius); 

                const allTargets = [];
                if (isBossWave) {
                    if (boss && !boss.isDead) allTargets.push(boss);
                    allTargets.push(...missiles);
                } else {
                    allTargets.push(...enemies);
                }

                for (const target of allTargets) {
                    // Check if target is valid, active, and has NOT been hit by THIS wave instance yet
                    if (target && !target.isDead && target.isActive && !e.enemiesHit.has(target)) {
                        const distanceToWaveCenter = dist(e.x, e.y, target.x, target.y);
                        
                        // Detect if the wave's expanding edge JUST crossed the target
                        if (distanceToWaveCenter <= e.radius && distanceToWaveCenter > previousRadius) {
                            if (target instanceof Missile) {
                                target.takeDamage(999); 
                            } else { 
                                target.takeDamage(player.skillE.damage);
                                if (target instanceof Enemy) { 
                                    const angleToEnemy = Math.atan2(target.y - e.y, target.x - e.x);
                                    target.applyKnockback(Math.cos(angleToEnemy) * player.skillE.knockback, Math.sin(angleToEnemy) * player.skillE.knockback);
                                }
                            }
                            e.enemiesHit.add(target); 
                        }
                    }
                }
                return e.radius < e.maxRadius; 
            });

            checkCollisions();

            // --- Drawing ---
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawStars(ctx);
            player.draw(ctx);
            if (isBossWave && boss) boss.draw(ctx);
            missiles.forEach(m => m.draw(ctx));
            playerProjectiles.forEach(proj => proj.draw(ctx));
            enemies.forEach(enemy => enemy.draw(ctx));
            particles.forEach(p => p.draw(ctx));
            
            // Draw skill effects
             lightningEffects.forEach(e => {
                ctx.globalAlpha = e.lifetime / 0.2; ctx.beginPath(); ctx.moveTo(e.x1, e.y1);
                const segments = 5;
                for (let i = 1; i <= segments; i++) {
                    const frac = i / segments; const midX = e.x1 + (e.x2 - e.x1) * frac; const midY = e.y1 + (e.y2 - e.y1) * frac;
                    const perpAngle = Math.atan2(e.y2 - e.y1, e.x2 - e.x1) + Math.PI / 2;
                    const offset = (Math.random() - 0.5) * 20; ctx.lineTo(midX + Math.cos(perpAngle) * offset, midY + Math.sin(perpAngle) * offset);
                }
                ctx.lineTo(e.x2, e.y2);
                ctx.strokeStyle = COLOR_SKILL_Q; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = COLOR_SKILL_Q; ctx.stroke();
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            });
            waveEffects.forEach(e => {
                ctx.globalAlpha = e.alpha; ctx.strokeStyle = COLOR_SKILL_E_INNER; ctx.lineWidth = 3;
                ctx.shadowBlur = 15; ctx.shadowColor = COLOR_SKILL_E_INNER;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius * 0.8, 0, Math.PI * 2); ctx.stroke();
                ctx.strokeStyle = COLOR_SKILL_E_OUTER; ctx.lineWidth = 8; ctx.shadowBlur = 25; ctx.shadowColor = COLOR_SKILL_E_OUTER;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.stroke();
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            });

            if (player.activeLaserEffect) {
                player.activeLaserEffect.draw(ctx);
            }


            // Draw Wave Announcement / BOSS WARNING
            if (performance.now() - waveTextDisplayTime < WAVE_TEXT_DURATION) {
                const elapsed = performance.now() - waveTextDisplayTime;
                let alpha = 0, scale = 1;
                if (elapsed < 500) { alpha = elapsed / 500; scale = 0.5 + 0.5 * alpha; } 
                else if (elapsed < WAVE_TEXT_DURATION - 500) { alpha = 1; scale = 1.5; } 
                else { alpha = 1 - (elapsed - (WAVE_TEXT_DURATION - 500)) / 500; scale = 1.5 - 0.5 * (1 - alpha); }
                alpha = clamp(alpha, 0, 1); scale = clamp(scale, 0.5, 1.5);
                ctx.save();
                ctx.globalAlpha = alpha; ctx.fillStyle = COLOR_PLAYER;
                ctx.font = `bold ${70 * scale}px Arial`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.shadowBlur = 20; ctx.shadowColor = COLOR_PLAYER;
                const waveText = isBossWave ? `!!! BOSS WAVE !!!` : `WAVE ${currentWave}`;
                ctx.fillText(waveText, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                ctx.restore();
            }

            drawCrosshair(ctx);
            updateHUD();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        window.onload = initGame;
    </script>
</body>
</html>