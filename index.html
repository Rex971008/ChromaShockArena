<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ChromaShock Arena (炫彩衝擊競技場)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #000000; /* Pure black background for visual contrast */
            color: #FFFFFF; /* Default text color */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        canvas {
            display: block;
            background-color: #050515; /* Very dark navy for space background */
            border: 2px solid #00FFFF; /* Cyan border */
            box-shadow: 0 0 20px 5px rgba(0, 255, 255, 0.5); /* Cyan glow */
        }

        .ui-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85); /* Semi-transparent black */
            border: 2px solid #00CCFF; /* Cyan border */
            box-shadow: 0 0 25px 8px rgba(0, 204, 255, 0.6); /* Stronger cyan glow */
            padding: 30px 40px;
            text-align: center;
            border-radius: 10px;
            max-width: 90%;
            display: none; /* Hidden by default */
            z-index: 1000; /* Ensure UI is on top */
        }

        .ui-screen h1, .ui-screen h2 {
            color: #00FFFF; /* Bright cyan for titles */
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00FFFF;
        }

        .ui-screen p {
            font-size: 1.2em;
            margin-bottom: 15px;
        }

        .ui-screen button {
            background-color: #00CCFF; /* Cyan button */
            color: #000000; /* Black text */
            border: none;
            padding: 12px 25px;
            margin: 10px;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            box-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
        }

        .ui-screen button:hover {
            background-color: #00FFFF; /* Lighter cyan on hover */
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }

        .ui-screen button:active {
            transform: translateY(0);
        }

        /* HUD Overlay */
        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow mouse events to pass through to canvas */
            display: none; /* Hidden by default */
        }

        #score-display, #wave-display, #health-bar-container {
            position: absolute;
            color: #FFFFFF;
            font-size: 1.5em;
            text-shadow: 0 0 5px #00FFFF;
        }

        #score-display { top: 20px; left: 20px; }
        #wave-display { top: 60px; left: 20px; }

        #health-bar-container {
            top: 100px;
            left: 20px;
            width: 200px; /* Fixed width for health bar */
            height: 20px;
            background-color: rgba(255, 0, 255, 0.3); /* Magenta transparent background */
            border: 2px solid #FF00FF; /* Magenta border */
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 0 8px rgba(255, 0, 255, 0.5);
        }

        #health-bar {
            height: 100%;
            width: 100%; /* Will be updated by JS */
            background-color: #00FFFF; /* Cyan fill */
            transition: width 0.1s linear; /* Smooth health change */
            box-shadow: 0 0 5px #00FFFF;
        }

        #skill-hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 15px;
        }

        .skill-icon {
            width: 60px;
            height: 60px;
            border: 2px solid #00FFFF;
            border-radius: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            font-weight: bold;
            color: #00FFFF;
            position: relative;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .skill-cooldown {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            color: #FFFFFF;
            text-shadow: 0 0 5px #FFFFFF;
            pointer-events: none;
        }

        .skill-icon.ready {
            box-shadow: 0 0 15px #00FFFF, 0 0 25px rgba(0, 255, 255, 0.7);
        }

        /* Upgrade Screen */
        #upgrade-screen h2 {
            color: #00FFFF;
            margin-bottom: 20px;
            text-shadow: 0 0 8px #00FFFF;
        }

        #current-money {
            color: #FFFF00;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-shadow: 0 0 8px #FFFF00;
        }

        #upgrade-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            max-height: 60vh;
            overflow-y: auto;
            padding-right: 10px; /* For scrollbar */
        }

        .upgrade-item {
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #00CCFF;
            padding: 15px;
            border-radius: 8px;
            text-align: left;
            box-shadow: 0 0 10px rgba(0, 204, 255, 0.3);
            position: relative;
        }

        .upgrade-item h4 {
            color: #FF00FF; /* Magenta for category */
            margin-top: 0;
            margin-bottom: 5px;
            font-size: 1.1em;
        }
        .upgrade-item h3 {
            color: #FFFF00; /* Yellow for item name */
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1.3em;
        }

        .upgrade-item p {
            font-size: 0.9em;
            line-height: 1.4;
            color: #CCC;
            margin-bottom: 10px;
        }

        .upgrade-item .level-info {
            font-weight: bold;
            color: #00FFFF;
            margin-bottom: 5px;
        }

        .upgrade-item .cost-info {
            font-weight: bold;
            color: #FFFF00;
            margin-bottom: 10px;
        }
        .upgrade-item button {
            width: calc(100% - 20px); /* Adjust for padding */
            font-size: 0.95em;
            margin: 5px 0 0 0;
        }
        .upgrade-item button:disabled {
            background-color: rgba(0, 204, 255, 0.3);
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Game Over Screen & Pause Screen*/
        #game-over-menu h2, #pause-menu h2 {
            color: #FF00FF; /* Magenta */
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #FF00FF;
        }

        #game-over-menu p {
            color: #FF00FF; /* Magenta for stats */
            font-size: 1.5em;
            margin-bottom: 10px;
        }
        
        /* === MOBILE CONTROLS === */
        #mobile-controls-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 35%; /* Area for controls */
            pointer-events: none; /* Container itself doesn't block */
            display: none; /* Hidden by default */
            z-index: 1001;
        }

        .joystick-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 200px;
            pointer-events: auto; /* Enable touch in this area */
        }

        .joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background-color: rgba(0, 255, 255, 0.1);
            border: 2px solid rgba(0, 255, 255, 0.4);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .joystick-stick {
            position: absolute;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background-color: rgba(0, 255, 255, 0.4);
            border: 2px solid #00FFFF;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .action-buttons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 20px;
            pointer-events: auto;
        }

        .action-button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 2px solid;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
            color: #FFFFFF;
            background-color: rgba(0, 0, 0, 0.5);
            text-shadow: 0 0 8px;
            user-select: none; /* Prevent text selection */
        }
        
        #mobile-fire-btn { border-color: #00FFFF; box-shadow: 0 0 15px #00FFFF; color: #00FFFF; grid-column: 2; grid-row: 1; transform: scale(1.2); }
        #mobile-skill-q-btn { border-color: #00FFFF; box-shadow: 0 0 10px #00FFFF; color: #00FFFF; }
        #mobile-skill-e-btn { border-color: #FFA500; box-shadow: 0 0 10px #FFA500; color: #FFA500; }
        #mobile-skill-rmb-btn { border-color: #FF00FF; box-shadow: 0 0 10px #FF00FF; color: #FF00FF; }

        .action-button.active {
             transform: scale(0.95);
             background-color: rgba(255, 255, 255, 0.3);
        }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- Main Menu -->
    <div id="main-menu" class="ui-screen">
        <h1>ChromaShock Arena</h1>
        <p>歡迎來到炫彩衝擊競技場！</p>
        <button id="start-game-btn">開始遊戲</button>
        <button id="upgrades-btn">永久升級</button>
        <p id="high-score-display">最高分數：0</p>
    </div>

    <!-- Upgrade Screen -->
    <div id="upgrade-screen" class="ui-screen">
        <h2>永久升級</h2>
        <p id="current-money">金錢：0</p>
        <div id="upgrade-list">
            <!-- Upgrade items will be dynamically inserted here -->
        </div>
        <button id="back-from-upgrades-btn">返回</button>
    </div>

    <!-- Game Over Menu -->
    <div id="game-over-menu" class="ui-screen">
        <h2>遊戲結束！</h2>
        <p>本局得分：<span id="final-score">0</span></p>
        <p>最高波次：<span id="final-wave">0</span></p>
        <p>獲得金錢：<span id="gained-money">0</span></p>
        <button id="return-to-main-menu-btn">返回主選單</button>
    </div>

    <!-- Pause Menu -->
    <div id="pause-menu" class="ui-screen">
        <h2>遊戲暫停</h2>
        <button id="resume-game-btn">繼續遊戲</button>
        <button id="exit-game-btn">退出遊戲</button>
    </div>

    <!-- HUD Overlay (Always present when game is running) -->
    <div id="ui-overlay">
        <div id="score-display">分數：0</div>
        <div id="wave-display">WAVE：1 | 剩餘敵人：0</div>
        <div id="health-bar-container">
            <div id="health-bar"></div>
        </div>
        <div id="skill-hud">
            <div id="skill-q" class="skill-icon ready">Q<div class="skill-cooldown" style="display: none;"></div></div>
            <div id="skill-e" class="skill-icon ready">E<div class="skill-cooldown" style="display: none;"></div></div>
            <div id="skill-right-click" class="skill-icon ready">RMB<div class="skill-cooldown" style="display: none;"></div></div>
        </div>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls-container">
        <div class="joystick-area">
            <div class="joystick-base"></div>
            <div class="joystick-stick"></div>
        </div>
        <div class="action-buttons">
            <div id="mobile-skill-q-btn" class="action-button">Q</div>
            <div id="mobile-skill-e-btn" class="action-button">E</div>
            <div id="mobile-skill-rmb-btn" class="action-button">R</div>
            <div id="mobile-fire-btn" class="action-button">🔥</div>
        </div>
    </div>


    <script>
        // === Constants and Game Configuration ===
        const CANVAS_WIDTH = 1200;
        const CANVAS_HEIGHT = 800;

        const PLAYER_MAX_HEALTH_BASE = 100;
        const PLAYER_MOVE_SPEED_BASE = 300; // pixels per second
        const PLAYER_FIRE_RATE_BASE = 8; // shots per second
        const PLAYER_BULLET_DAMAGE_BASE = 10;
        const PLAYER_HEALTH_REGEN_BASE = 0.5; // health per second
        const PLAYER_BULLETS_PER_SHOT_BASE = 1; // NEW: Base value for multi-shot

        const SKILL_Q_DAMAGE_BASE = 40;
        const SKILL_Q_TARGETS_BASE = 4;
        const SKILL_Q_COOLDOWN = 8; // seconds

        const SKILL_E_DAMAGE_BASE = 20;
        const SKILL_E_RADIUS_BASE = 200;
        const SKILL_E_KNOCKBACK_BASE = 50;
        const SKILL_E_COOLDOWN = 6; // seconds

        const SKILL_RMB_DAMAGE_BASE = 10; // damage per frame
        const SKILL_RMB_DURATION_BASE = 300; // milliseconds
        const SKILL_RMB_COOLDOWN = 10; // seconds

        const BULLET_SPEED = 800; // pixels per second
        const ENEMY_SPAWN_OFFSET = 50; // Spawn enemies this far off screen

        const WAVE_INITIAL_ENEMY_COUNT = 8;
        const WAVE_ENEMY_COUNT_PER_WAVE = 3;
        const WAVE_ENEMY_HP_SCALING = 0.18; // 18% per wave after wave 1
        const WAVE_ENEMY_SPEED_SCALING = 0.06; // 6% per wave after wave 1
        const WAVE_SPAWN_INTERVAL_BASE = 500; // ms
        const WAVE_SPAWN_INTERVAL_DECREASE = 20; // ms per wave
        const WAVE_SPAWN_INTERVAL_MIN = 100; // ms

        // --- Colors ---
        const COLOR_PLAYER = '#00FFFF'; // Cyan
        const COLOR_PLAYER_BULLET = '#00FFFF'; // Cyan
        const COLOR_ENEMY_GRUNT = '#FF0000'; // Bright Red
        const COLOR_ENEMY_SCOUT = '#FFFF00'; // Bright Yellow
        const COLOR_ENEMY_BRUTE = '#FF00FF'; // Magenta
        const COLOR_EXPLOSION_PARTICLE = ['#FF0000', '#FFA500', '#FFFF00', '#FF00FF']; // Red, Orange, Yellow, Magenta
        const COLOR_SKILL_Q = '#CCFFFF'; // Light Cyan
        const COLOR_SKILL_E_INNER = '#FFFFFF'; // White
        const COLOR_SKILL_E_OUTER = '#FFA500'; // Orange
        const COLOR_SKILL_RMB = '#FF00FF'; // Magenta
        const COLOR_CROSSHAIR = '#FFFFFF'; // White for crosshair

        // --- Permanent Upgrade Definitions ---
        const UPGRADES_DEFINITION = {
            'bulletDamage': {
                category: '基礎', name: '子彈傷害', effect: '提升每顆子彈的傷害',
                baseValue: PLAYER_BULLET_DAMAGE_BASE, increment: 2,
                initialPrice: 50, priceFactor: 1.35
            },
            'fireRate': {
                category: '基礎', name: '射擊頻率', effect: '提升每秒可發射的子彈數',
                baseValue: PLAYER_FIRE_RATE_BASE, increment: 1.10, type: 'multiply',
                initialPrice: 60, priceFactor: 1.4
            },
            'bulletsPerShot': { // NEW UPGRADE
                category: '基礎', name: '多重射擊', effect: '每次射擊發射的子彈數量',
                baseValue: PLAYER_BULLETS_PER_SHOT_BASE, increment: 1,
                initialPrice: 75, priceFactor: 1.4 // Slightly more than damage, less than fire rate
            },
            'maxHealth': {
                category: '基礎', name: '最大生命', effect: '提升生命值上限',
                baseValue: PLAYER_MAX_HEALTH_BASE, increment: 25,
                initialPrice: 70, priceFactor: 1.38
            },
            'healthRegen': {
                category: '基礎', name: '生命恢復', effect: '提升每秒恢復的生命值',
                baseValue: PLAYER_HEALTH_REGEN_BASE, increment: 0.3,
                initialPrice: 90, priceFactor: 1.45
            },
            'moveSpeed': {
                category: '基礎', name: '移動速度', effect: '提升飛船的移動速度',
                baseValue: PLAYER_MOVE_SPEED_BASE, increment: 20,
                initialPrice: 80, priceFactor: 1.3
            },
            'waveRadius': {
                category: '波動 [E]', name: '半徑', effect: '增加波動攻擊的擴散半徑',
                baseValue: SKILL_E_RADIUS_BASE, increment: 25,
                initialPrice: 100, priceFactor: 1.42
            },
            'waveDamage': {
                category: '波動 [E]', name: '傷害', effect: '增加波動攻擊的傷害',
                baseValue: SKILL_E_DAMAGE_BASE, increment: 6,
                initialPrice: 120, priceFactor: 1.48
            },
            'waveKnockback': {
                category: '波動 [E]', name: '推力', effect: '增強波動對敵人的推開力度',
                baseValue: SKILL_E_KNOCKBACK_BASE, increment: 15,
                initialPrice: 90, priceFactor: 1.35
            },
            'lightningTargets': {
                category: '閃電 [Q]', name: '目標數', effect: '增加閃電鏈可彈射的敵人數量',
                baseValue: SKILL_Q_TARGETS_BASE, increment: 1,
                initialPrice: 150, priceFactor: 1.5
            },
            'lightningDamage': {
                category: '閃電 [Q]', name: '傷害', effect: '增加每次閃電的傷害',
                baseValue: SKILL_Q_DAMAGE_BASE, increment: 12,
                initialPrice: 180, priceFactor: 1.55
            },
            'laserDuration': {
                category: '雷射 [右鍵]', name: '持續時間', effect: '增加雷射光束的持續時間',
                baseValue: SKILL_RMB_DURATION_BASE, increment: 60,
                initialPrice: 140, priceFactor: 1.52
            },
            'laserDamage': {
                category: '雷射 [右鍵]', name: '傷害', effect: '增加雷射每幀造成的傷害',
                baseValue: SKILL_RMB_DAMAGE_BASE, increment: 6,
                initialPrice: 200, priceFactor: 1.6
            }
        };

        // === Game State Variables ===
        let canvas, ctx;
        let animationFrameId;
        let lastTime = 0;
        let deltaTime = 0;

        let gameRunning = false;
        let gamePaused = false;
        let currentScreen = 'main-menu';

        let player;
        let enemies = [];
        let playerProjectiles = [];
        let particles = [];
        let lightningEffects = [];
        let waveEffects = []; 

        let currentScore = 0;
        let currentWave = 1;
        let enemiesInWave = 0;
        let enemiesSpawnedThisWave = 0;
        let lastEnemySpawnTime = 0;
        let waveTextDisplayTime = 0;
        const WAVE_TEXT_DURATION = 2000; // ms

        let playerMoney = 0;
        let highScore = 0;
        let playerUpgradeLevels = {}; 

        // --- Input States ---
        const keys = {};
        const mouse = { x: 0, y: 0, leftPressed: false, rightPressed: false };
        let usingTouch = false;
        const touchJoystick = {
            active: false,
            touchId: null,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            dx: 0,
            dy: 0,
            angle: 0,
            distance: 0
        };
        const touchButtons = {
            fire: { active: false, id: 'mobile-fire-btn' },
            q: { active: false, id: 'mobile-skill-q-btn' },
            e: { active: false, id: 'mobile-skill-e-btn' },
            rmb: { active: false, id: 'mobile-skill-rmb-btn' }
        };

        // === DOM Elements ===
        const mainMenu = document.getElementById('main-menu');
        const upgradeScreen = document.getElementById('upgrade-screen');
        const gameOverMenu = document.getElementById('game-over-menu');
        const pauseMenu = document.getElementById('pause-menu');
        const uiOverlay = document.getElementById('ui-overlay');
        const mobileControlsContainer = document.getElementById('mobile-controls-container');

        const startGameBtn = document.getElementById('start-game-btn');
        const upgradesBtn = document.getElementById('upgrades-btn');
        const highScoreDisplay = document.getElementById('high-score-display');

        const currentMoneyDisplay = document.getElementById('current-money');
        const upgradeListDiv = document.getElementById('upgrade-list');
        const backFromUpgradesBtn = document.getElementById('back-from-upgrades-btn');

        const finalScoreDisplay = document.getElementById('final-score');
        const finalWaveDisplay = document.getElementById('final-wave');
        const gainedMoneyDisplay = document.getElementById('gained-money');
        const returnToMainMenuBtn = document.getElementById('return-to-main-menu-btn');

        const resumeGameBtn = document.getElementById('resume-game-btn');
        const exitGameBtn = document.getElementById('exit-game-btn');

        const scoreDisplay = document.getElementById('score-display');
        const waveDisplay = document.getElementById('wave-display');
        const healthBar = document.getElementById('health-bar');
        const skillQIcon = document.getElementById('skill-q');
        const skillEIcon = document.getElementById('skill-e');
        const skillRMBIcon = document.getElementById('skill-right-click');
        const joystickStick = document.querySelector('.joystick-stick');


        // === Helper Functions ===
        function isTouchDevice() {
            return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(value, max));
        }

        function dist(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        const pool = {
            projectiles: [],
            particles: [],
            getProjectile() { return this.projectiles.pop() || new Projectile(0,0,0,0,0,0); },
            returnProjectile(proj) { this.projectiles.push(proj); },
            getParticle() { return this.particles.pop() || new Particle(0,0,0,0,0,0,0,0); },
            returnParticle(part) { this.particles.push(part); }
        };

        // --- localStorage Management ---
        function saveGame() {
            const gameData = { money: playerMoney, highScore: highScore, upgradeLevels: playerUpgradeLevels };
            localStorage.setItem('chromashockArenaData', JSON.stringify(gameData));
        }

        function loadGame() {
            const savedData = localStorage.getItem('chromashockArenaData');
            if (savedData) {
                const gameData = JSON.parse(savedData);
                playerMoney = gameData.money || 0;
                highScore = gameData.highScore || 0;
                playerUpgradeLevels = gameData.upgradeLevels || {};
            } else {
                for (const key in UPGRADES_DEFINITION) {
                    playerUpgradeLevels[key] = 0;
                }
            }
        }

        // --- UI Management ---
        function showScreen(screenId) {
            mainMenu.style.display = 'none';
            upgradeScreen.style.display = 'none';
            gameOverMenu.style.display = 'none';
            pauseMenu.style.display = 'none';
            uiOverlay.style.display = 'none';
            mobileControlsContainer.style.display = 'none';
            gameRunning = false;
            gamePaused = false;
            cancelAnimationFrame(animationFrameId);

            if (screenId === 'main-menu') {
                mainMenu.style.display = 'block';
                highScoreDisplay.textContent = `最高分數：${highScore}`;
            } else if (screenId === 'upgrade-screen') {
                upgradeScreen.style.display = 'block';
                populateUpgradeList();
            } else if (screenId === 'game-over-menu') {
                gameOverMenu.style.display = 'block';
            } else if (screenId === 'pause-menu') {
                pauseMenu.style.display = 'block';
                gamePaused = true; 
            }
            else if (screenId === 'game') {
                uiOverlay.style.display = 'block';
                if(usingTouch) mobileControlsContainer.style.display = 'block';
                gameRunning = true;
                lastTime = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            currentScreen = screenId;
        }

        function populateUpgradeList() {
            currentMoneyDisplay.textContent = `金錢：${playerMoney}`;
            upgradeListDiv.innerHTML = ''; 

            for (const key in UPGRADES_DEFINITION) {
                const def = UPGRADES_DEFINITION[key];
                const currentLevel = playerUpgradeLevels[key] || 0;
                const nextLevel = currentLevel + 1;

                let currentValue;
                let nextValue;
                let nextPrice = Math.round(def.initialPrice * Math.pow(def.priceFactor, currentLevel));

                if (def.type === 'multiply') {
                    currentValue = def.baseValue * Math.pow(def.increment, currentLevel);
                    nextValue = def.baseValue * Math.pow(def.increment, nextLevel);
                } else {
                    currentValue = def.baseValue + def.increment * currentLevel;
                    nextValue = def.baseValue + def.increment * nextLevel;
                }

                const itemDiv = document.createElement('div');
                itemDiv.classList.add('upgrade-item');
                itemDiv.innerHTML = `
                    <h4>${def.category}</h4>
                    <h3>${def.name}</h3>
                    <p>${def.effect}</p>
                    <p class="level-info">等級: ${currentLevel}</p>
                    <p>當前: ${def.type === 'multiply' ? currentValue.toFixed(2) : currentValue.toFixed(0)}</p>
                    <p>下級: ${def.type === 'multiply' ? nextValue.toFixed(2) : nextValue.toFixed(0)}</p>
                    <p class="cost-info">價格: ${nextPrice} 金</p>
                    <button data-upgrade-key="${key}" data-price="${nextPrice}">購買</button>
                `;

                const buyButton = itemDiv.querySelector('button');
                if (playerMoney < nextPrice) {
                    buyButton.disabled = true;
                    buyButton.textContent = '金錢不足';
                } else {
                    buyButton.onclick = () => buyUpgrade(key, nextPrice);
                }
                upgradeListDiv.appendChild(itemDiv);
            }
        }

        function buyUpgrade(key, price) {
            if (playerMoney >= price) {
                playerMoney -= price;
                playerUpgradeLevels[key]++;
                saveGame();
                populateUpgradeList();
            }
        }

        function updatePlayerStatsFromUpgrades() {
            if (!player) return;

            player.maxHealth = PLAYER_MAX_HEALTH_BASE;
            player.healthRegen = PLAYER_HEALTH_REGEN_BASE;
            player.moveSpeed = PLAYER_MOVE_SPEED_BASE;
            player.baseBulletDamage = PLAYER_BULLET_DAMAGE_BASE;
            player.fireRate = PLAYER_FIRE_RATE_BASE;
            player.bulletsPerShot = PLAYER_BULLETS_PER_SHOT_BASE;

            player.skillQ.damage = SKILL_Q_DAMAGE_BASE;
            player.skillQ.targets = SKILL_Q_TARGETS_BASE;
            player.skillE.damage = SKILL_E_DAMAGE_BASE;
            player.skillE.radius = SKILL_E_RADIUS_BASE;
            player.skillE.knockback = SKILL_E_KNOCKBACK_BASE;
            player.skillRMB.damagePerFrame = SKILL_RMB_DAMAGE_BASE;
            player.skillRMB.duration = SKILL_RMB_DURATION_BASE;

            for (const key in playerUpgradeLevels) {
                const level = playerUpgradeLevels[key];
                if (!level) continue; 
                
                const def = UPGRADES_DEFINITION[key];
                if (level > 0) {
                    if (def.type === 'multiply') {
                        const multiplier = Math.pow(def.increment, level);
                        if (key === 'fireRate') player.fireRate *= multiplier;
                    } else {
                        const addedValue = def.increment * level;
                        if (key === 'bulletDamage') player.baseBulletDamage += addedValue;
                        else if (key === 'bulletsPerShot') player.bulletsPerShot += addedValue;
                        else if (key === 'maxHealth') player.maxHealth += addedValue;
                        else if (key === 'healthRegen') player.healthRegen += addedValue;
                        else if (key === 'moveSpeed') player.moveSpeed += addedValue;
                        else if (key === 'waveRadius') player.skillE.radius += addedValue;
                        else if (key === 'waveDamage') player.skillE.damage += addedValue;
                        else if (key === 'waveKnockback') player.skillE.knockback += addedValue;
                        else if (key === 'lightningTargets') player.skillQ.targets += addedValue;
                        else if (key === 'lightningDamage') player.skillQ.damage += addedValue;
                        else if (key === 'laserDuration') player.skillRMB.duration += addedValue;
                        else if (key === 'laserDamage') player.skillRMB.damagePerFrame += addedValue;
                    }
                }
            }
            player.health = player.maxHealth;
        }

        function updateHUD() {
            scoreDisplay.textContent = `分數：${currentScore}`;
            waveDisplay.textContent = `WAVE：${currentWave} | 剩餘敵人：${enemiesInWave - enemiesSpawnedThisWave + enemies.length}`;
            healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
            healthBar.style.backgroundColor = player.health <= 0 ? '#FF00FF' : COLOR_PLAYER;

            const skillQReady = player.skillQ.cooldownLeft <= 0;
            const skillEReady = player.skillE.cooldownLeft <= 0;
            const skillRMBReady = player.skillRMB.cooldownLeft <= 0;

            updateSkillIcon(skillQIcon, player.skillQ.cooldownLeft, SKILL_Q_COOLDOWN);
            updateSkillIcon(skillEIcon, player.skillE.cooldownLeft, SKILL_E_COOLDOWN);
            updateSkillIcon(skillRMBIcon, player.skillRMB.cooldownLeft, SKILL_RMB_COOLDOWN);

            if (usingTouch) {
                document.getElementById('mobile-skill-q-btn').style.opacity = skillQReady ? 1 : 0.5;
                document.getElementById('mobile-skill-e-btn').style.opacity = skillEReady ? 1 : 0.5;
                document.getElementById('mobile-skill-rmb-btn').style.opacity = skillRMBReady ? 1 : 0.5;
            }
        }

        function updateSkillIcon(iconElement, cooldownLeft, totalCooldown) {
            const cooldownDisplay = iconElement.querySelector('.skill-cooldown');
            if (cooldownLeft > 0) {
                iconElement.classList.remove('ready');
                cooldownDisplay.style.display = 'flex';
                cooldownDisplay.textContent = Math.ceil(cooldownLeft);
            } else {
                iconElement.classList.add('ready');
                cooldownDisplay.style.display = 'none';
            }
        }

        // === Game Entity Classes ===

        class Player {
            constructor() {
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT / 2;
                this.radius = 15;
                this.color = COLOR_PLAYER;
                this.health = PLAYER_MAX_HEALTH_BASE;
                this.maxHealth = PLAYER_MAX_HEALTH_BASE;
                this.healthRegen = PLAYER_HEALTH_REGEN_BASE;
                this.moveSpeed = PLAYER_MOVE_SPEED_BASE;
                this.angle = 0;

                this.baseBulletDamage = PLAYER_BULLET_DAMAGE_BASE;
                this.fireRate = PLAYER_FIRE_RATE_BASE;
                this.bulletsPerShot = PLAYER_BULLETS_PER_SHOT_BASE;
                this.lastShotTime = 0;

                this.skillQ = { cooldownLeft: 0, damage: SKILL_Q_DAMAGE_BASE, targets: SKILL_Q_TARGETS_BASE, lastUsed: 0 };
                this.skillE = { cooldownLeft: 0, damage: SKILL_E_DAMAGE_BASE, radius: SKILL_E_RADIUS_BASE, knockback: SKILL_E_KNOCKBACK_BASE, lastUsed: 0 };
                this.skillRMB = { cooldownLeft: 0, damagePerFrame: SKILL_RMB_DAMAGE_BASE, duration: SKILL_RMB_DURATION_BASE, lastUsed: 0, isActive: false, activeTimer: 0 };

                this.isDead = false;
                this.activeLaserEffect = null;
            }

            update(deltaTime) {
                if (this.isDead) return;

                // --- Movement ---
                let moveAngle = null;
                // Touch controls take precedence
                if (usingTouch && touchJoystick.active) {
                    moveAngle = touchJoystick.angle;
                } else {
                    let dx = 0;
                    let dy = 0;
                    if (keys['w']) dy -= 1;
                    if (keys['s']) dy += 1;
                    if (keys['a']) dx -= 1;
                    if (keys['d']) dx += 1;
                    if (dx !== 0 || dy !== 0) {
                        moveAngle = Math.atan2(dy, dx);
                    }
                }

                if (moveAngle !== null) {
                    this.x += Math.cos(moveAngle) * this.moveSpeed * deltaTime;
                    this.y += Math.sin(moveAngle) * this.moveSpeed * deltaTime;
                }

                this.x = clamp(this.x, this.radius, CANVAS_WIDTH - this.radius);
                this.y = clamp(this.y, this.radius, CANVAS_HEIGHT - this.radius);

                // --- Aiming ---
                if (usingTouch) {
                    // Aim in the direction of movement if joystick is active, otherwise keep last angle
                    if (touchJoystick.active) {
                        this.angle = touchJoystick.angle;
                    }
                } else {
                    this.angle = Math.atan2(mouse.y - this.y, mouse.x - this.x);
                }

                // --- Shooting ---
                const isShooting = usingTouch ? touchButtons.fire.active : mouse.leftPressed;
                if (isShooting && (performance.now() - this.lastShotTime) > (1000 / this.fireRate)) {
                    const numBullets = this.bulletsPerShot;
                    const totalSpreadAngle = Math.PI / 8; 
                    const angleStep = numBullets > 1 ? totalSpreadAngle / (numBullets - 1) : 0;
                    const startAngleOffset = numBullets > 1 ? -totalSpreadAngle / 2 : 0;

                    for (let i = 0; i < numBullets; i++) {
                        const currentBulletAngle = this.angle + startAngleOffset + (angleStep * i);
                        const bulletX = this.x + Math.cos(currentBulletAngle) * this.radius;
                        const bulletY = this.y + Math.sin(currentBulletAngle) * this.radius;
                        const bullet = pool.getProjectile();
                        bullet.reset(bulletX, bulletY, Math.cos(currentBulletAngle), Math.sin(currentBulletAngle), BULLET_SPEED, this.baseBulletDamage, 'player');
                        playerProjectiles.push(bullet);
                    }
                    this.lastShotTime = performance.now();
                }

                // --- Skill Cooldowns ---
                this.skillQ.cooldownLeft = Math.max(0, SKILL_Q_COOLDOWN - (performance.now() - this.skillQ.lastUsed) / 1000);
                this.skillE.cooldownLeft = Math.max(0, SKILL_E_COOLDOWN - (performance.now() - this.skillE.lastUsed) / 1000);
                this.skillRMB.cooldownLeft = Math.max(0, SKILL_RMB_COOLDOWN - (performance.now() - this.skillRMB.lastUsed) / 1000);

                // --- Skill Activation ---
                const q_pressed = usingTouch ? touchButtons.q.active : keys['q'];
                if (q_pressed && this.skillQ.cooldownLeft <= 0) {
                    this.activateSkillQ();
                    if (usingTouch) touchButtons.q.active = false; else keys['q'] = false;
                }
                const e_pressed = usingTouch ? touchButtons.e.active : keys['e'];
                if (e_pressed && this.skillE.cooldownLeft <= 0) {
                    this.activateSkillE();
                    if (usingTouch) touchButtons.e.active = false; else keys['e'] = false;
                }
                const rmb_pressed = usingTouch ? touchButtons.rmb.active : mouse.rightPressed;
                if (rmb_pressed && this.skillRMB.cooldownLeft <= 0 && !this.skillRMB.isActive) {
                    this.activateSkillRMB();
                    if (usingTouch) touchButtons.rmb.active = false; else mouse.rightPressed = false;
                }


                // --- Laser Beam Logic ---
                if (this.skillRMB.isActive) {
                    this.skillRMB.activeTimer += deltaTime * 1000;
                    if (this.skillRMB.activeTimer >= this.skillRMB.duration) {
                        this.skillRMB.isActive = false;
                        this.skillRMB.activeTimer = 0;
                        this.activeLaserEffect = null;
                    } else {
                        if (!this.activeLaserEffect) this.activeLaserEffect = new LaserEffect(this.x, this.y, this.x, this.y, COLOR_SKILL_RMB, 10, 1);
                        this.activeLaserEffect.x1 = this.x;
                        this.activeLaserEffect.y1 = this.y;
                        this.activeLaserEffect.x2 = this.x + Math.cos(this.angle) * CANVAS_WIDTH * 1.5;
                        this.activeLaserEffect.y2 = this.y + Math.sin(this.angle) * CANVAS_HEIGHT * 1.5;
                    }
                }

                // --- Health Regeneration & Game Over ---
                this.health += this.healthRegen * deltaTime;
                this.health = clamp(this.health, -Infinity, this.maxHealth);
                if (this.health <= 0 && !this.isDead) {
                    this.isDead = true;
                    endGame();
                }
            }

            draw(ctx) {
                if (this.isDead) return;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);

                ctx.beginPath();
                ctx.moveTo(this.radius, 0);
                ctx.lineTo(-this.radius, -this.radius / 1.5);
                ctx.lineTo(-this.radius, this.radius / 1.5);
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.beginPath();
                ctx.arc(-this.radius * 1.2, 0, this.radius * 0.8, -Math.PI / 2, Math.PI / 2, false);
                ctx.fillStyle = `rgba(0, 255, 255, 0.7)`;
                ctx.shadowBlur = 20;
                ctx.shadowColor = COLOR_PLAYER;
                ctx.fill();
                ctx.shadowBlur = 0;

                for (let i = 0; i < 2; i++) {
                    particles.push(new Particle(
                        this.x + Math.cos(this.angle + Math.PI) * this.radius * 1.2,
                        this.y + Math.sin(this.angle + Math.PI) * this.radius * 1.2 + (i === 0 ? -this.radius / 3 : this.radius / 3),
                        Math.cos(this.angle + Math.PI + (Math.random() - 0.5) * 0.5) * 100,
                        Math.sin(this.angle + Math.PI + (Math.random() - 0.5) * 0.5) * 100,
                        2 + Math.random() * 3, 0.5 + Math.random() * 0.5, COLOR_PLAYER, `rgba(0, 255, 255, ${0.5 + Math.random() * 0.5})`
                    ));
                }
                ctx.restore();
            }

            activateSkillQ() {
                this.skillQ.lastUsed = performance.now();
                const potentialTargets = enemies.filter(e => !e.isDead);
                potentialTargets.sort((a, b) => dist(this.x, this.y, a.x, a.y) - dist(this.x, this.y, b.x, b.y));
                let chainedTargets = [];
                let currentTarget = { x: this.x, y: this.y }; 

                for (let i = 0; i < this.skillQ.targets && potentialTargets.length > 0; i++) {
                    let nextTarget = null;
                    let nearestDist = Infinity;
                    let nearestIndex = -1;
                    for (let j = 0; j < potentialTargets.length; j++) {
                        const d = dist(currentTarget.x, currentTarget.y, potentialTargets[j].x, potentialTargets[j].y);
                        if (d < nearestDist) {
                            nearestDist = d;
                            nextTarget = potentialTargets[j];
                            nearestIndex = j;
                        }
                    }
                    if (nextTarget) {
                        lightningEffects.push({ x1: currentTarget.x, y1: currentTarget.y, x2: nextTarget.x, y2: nextTarget.y, lifetime: 0.2 });
                        nextTarget.takeDamage(this.skillQ.damage);
                        chainedTargets.push(nextTarget);
                        currentTarget = nextTarget;
                        potentialTargets.splice(nearestIndex, 1);
                    } else break;
                }
            }

            activateSkillE() {
                this.skillE.lastUsed = performance.now();
                waveEffects.push({ x: this.x, y: this.y, radius: 0, maxRadius: this.skillE.radius, speed: this.skillE.radius / 0.3, alpha: 1 });
                for (const enemy of enemies) {
                    if (enemy.isDead) continue;
                    if (dist(this.x, this.y, enemy.x, enemy.y) < this.skillE.radius) {
                        enemy.takeDamage(this.skillE.damage);
                        const angleToEnemy = Math.atan2(enemy.y - this.y, enemy.x - this.x);
                        enemy.applyKnockback(Math.cos(angleToEnemy) * this.skillE.knockback, Math.sin(angleToEnemy) * this.skillE.knockback);
                    }
                }
            }

            activateSkillRMB() {
                this.skillRMB.lastUsed = performance.now();
                this.skillRMB.isActive = true;
                this.skillRMB.activeTimer = 0;
                this.activeLaserEffect = new LaserEffect(this.x, this.y, this.x, this.y, COLOR_SKILL_RMB, 10, 1);
            }

            takeDamage(amount) {
                this.health -= amount;
                this.health = clamp(this.health, -Infinity, this.maxHealth);
                canvas.style.transform = `translate(${Math.random() * 5 - 2.5}px, ${Math.random() * 5 - 2.5}px)`;
                setTimeout(() => canvas.style.transform = '', 50);
            }
        }

        class Enemy {
             constructor(type, x, y, hp, speed, radius, color, behavior, scoreValue) {
                this.type = type; this.x = x; this.y = y; this.initialHealth = hp; this.health = hp; this.speed = speed; this.radius = radius;
                this.color = color; this.behavior = behavior; this.scoreValue = scoreValue; this.isDead = false; this.knockbackVelX = 0;
                this.knockbackVelY = 0; this.knockbackFriction = 0.9; this.oscillationTimer = Math.random() * Math.PI * 2;
            }
            update(deltaTime) {
                if (this.isDead) return;
                this.x += this.knockbackVelX * deltaTime; this.y += this.knockbackVelY * deltaTime;
                this.knockbackVelX *= this.knockbackFriction; this.knockbackVelY *= this.knockbackFriction;
                if (Math.abs(this.knockbackVelX) < 1) this.knockbackVelX = 0;
                if (Math.abs(this.knockbackVelY) < 1) this.knockbackVelY = 0;
                const dx = player.x - this.x; const dy = player.y - this.y; const angle = Math.atan2(dy, dx);
                let moveX = Math.cos(angle) * this.speed; let moveY = Math.sin(angle) * this.speed;
                if (this.behavior === 'chase_oscillate') {
                    this.oscillationTimer += deltaTime * 5; const oscillationOffset = Math.sin(this.oscillationTimer) * 50;
                    const perpAngle = angle + Math.PI / 2;
                    moveX += Math.cos(perpAngle) * oscillationOffset; moveY += Math.sin(perpAngle) * oscillationOffset;
                }
                this.x += moveX * deltaTime; this.y += moveY * deltaTime;
            }
            draw(ctx) {
                if (this.isDead) return;
                ctx.beginPath();
                if (this.type === 'Grunt' || this.type === 'Spitter') ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                else if (this.type === 'Scout') {
                    ctx.save(); ctx.translate(this.x, this.y); const angle = Math.atan2(player.y - this.y, player.x - this.x); ctx.rotate(angle);
                    ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius / 2, -this.radius * 0.866); ctx.lineTo(-this.radius / 2, this.radius * 0.866);
                    ctx.closePath(); ctx.restore();
                } else if (this.type === 'Brute') ctx.rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                ctx.fillStyle = this.color; ctx.shadowBlur = 10; ctx.shadowColor = this.color; ctx.fill();
                if (this.health < this.initialHealth) {
                    const healthBarWidth = this.radius * 2; const healthBarHeight = 3; const healthBarX = this.x - this.radius; const healthBarY = this.y - this.radius - 10;
                    ctx.fillStyle = `rgba(255, 0, 255, 0.4)`; ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);
                    ctx.fillStyle = `rgba(0, 255, 255, 0.8)`; ctx.fillRect(healthBarX, healthBarY, healthBarWidth * (this.health / this.initialHealth), healthBarHeight);
                }
                ctx.shadowBlur = 0;
            }
            takeDamage(amount) {
                if (this.isDead) return; this.health -= amount;
                if (this.health <= 0) { this.isDead = true; currentScore += this.scoreValue; this.explode(); }
            }
            applyKnockback(vx, vy) { this.knockbackVelX += vx; this.knockbackVelY += vy; }
            explode() {
                const numParticles = 20 + Math.random() * 10;
                for (let i = 0; i < numParticles; i++) {
                    const angle = Math.random() * Math.PI * 2; const speed = 100 + Math.random() * 300; const size = 3 + Math.random() * 5;
                    const lifetime = 0.5 + Math.random() * 0.5; const color = COLOR_EXPLOSION_PARTICLE[Math.floor(Math.random() * COLOR_EXPLOSION_PARTICLE.length)];
                    particles.push(new Particle(this.x, this.y, Math.cos(angle) * speed, Math.sin(angle) * speed, size, lifetime, color, color));
                }
                if (this.type === 'Brute') {
                    canvas.style.transform = `translate(${Math.random() * 8 - 4}px, ${Math.random() * 8 - 4}px)`;
                    setTimeout(() => canvas.style.transform = '', 70);
                }
            }
        }

        class Projectile {
            constructor(x, y, velX, velY, speed, damage, owner) { this.reset(x, y, velX, velY, speed, damage, owner); }
            reset(x, y, velX, velY, speed, damage, owner) {
                this.x = x; this.y = y; this.velX = velX * speed; this.velY = velY * speed; this.damage = damage;
                this.radius = 5; this.color = (owner === 'player') ? COLOR_PLAYER_BULLET : COLOR_ENEMY_GRUNT; this.owner = owner; this.isActive = true;
            }
            update(deltaTime) {
                if (!this.isActive) return; this.x += this.velX * deltaTime; this.y += this.velY * deltaTime;
                if (this.x < -this.radius || this.x > CANVAS_WIDTH + this.radius || this.y < -this.radius || this.y > CANVAS_HEIGHT + this.radius) this.isActive = false;
            }
            draw(ctx) {
                if (!this.isActive) return; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fillStyle = this.color;
                ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.fill(); ctx.shadowBlur = 0;
                if (this.owner === 'player') {
                    particles.push(new Particle(this.x - this.velX * deltaTime * 5, this.y - this.velY * deltaTime * 5, -this.velX * 0.1, -this.velY * 0.1, 2 + Math.random() * 2,
                    0.2 + Math.random() * 0.2, COLOR_PLAYER, `rgba(0, 255, 255, ${0.4 + Math.random() * 0.4})`));
                }
            }
        }

        class Particle {
            constructor(x, y, velX, velY, size, lifetime, color, glowColor) { this.reset(x, y, velX, velY, size, lifetime, color, glowColor); }
            reset(x, y, velX, velY, size, lifetime, color, glowColor) {
                this.x = x; this.y = y; this.velX = velX; this.velY = velY; this.size = size; this.lifetime = lifetime; this.timeAlive = 0;
                this.color = color; this.glowColor = glowColor || color; this.isActive = true;
            }
            update(deltaTime) {
                if (!this.isActive) return; this.x += this.velX * deltaTime; this.y += this.velY * deltaTime;
                this.timeAlive += deltaTime; if (this.timeAlive >= this.lifetime) this.isActive = false;
            }
            draw(ctx) {
                if (!this.isActive) return; const alpha = 1 - (this.timeAlive / this.lifetime); ctx.globalAlpha = alpha; ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fillStyle = this.glowColor; ctx.fill();
                ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1;
            }
        }

        class LaserEffect {
            constructor(x1, y1, x2, y2, color, width, alpha) {
                this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
                this.color = color; this.width = width; this.alpha = alpha;
            }
            draw(ctx) {
                ctx.globalAlpha = this.alpha; ctx.beginPath(); ctx.moveTo(this.x1, this.y1); ctx.lineTo(this.x2, this.y2);
                ctx.strokeStyle = this.color; ctx.lineWidth = this.width; ctx.shadowBlur = 20; ctx.shadowColor = this.color; ctx.stroke();
                ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth = this.width * 0.4; ctx.shadowBlur = 0; ctx.stroke(); ctx.globalAlpha = 1;
            }
        }

        // --- Background Stars ---
        const stars = [];
        let playerPrevX = CANVAS_WIDTH / 2;
        let playerPrevY = CANVAS_HEIGHT / 2;
        function createStars() { for (let i = 0; i < 400; i++) stars.push({ x: Math.random() * CANVAS_WIDTH, y: Math.random() * CANVAS_HEIGHT, size: Math.random() * 2, layer: Math.floor(Math.random() * 3) }); }
        function drawStars(ctx) {
            const dx = player.x - playerPrevX; const dy = player.y - playerPrevY; ctx.fillStyle = '#FFFFFF';
            for (const star of stars) {
                let parallaxSpeed, alphaMultiplier;
                switch (star.layer) {
                    case 0: parallaxSpeed = 0.05; alphaMultiplier = 0.4; break;
                    case 1: parallaxSpeed = 0.15; alphaMultiplier = 0.6; break;
                    case 2: parallaxSpeed = 0.3; alphaMultiplier = 0.8; break;
                }
                star.x -= dx * parallaxSpeed; star.y -= dy * parallaxSpeed;
                if (star.x < 0) star.x += CANVAS_WIDTH; if (star.x > CANVAS_WIDTH) star.x -= CANVAS_WIDTH;
                if (star.y < 0) star.y += CANVAS_HEIGHT; if (star.y > CANVAS_HEIGHT) star.y -= CANVAS_HEIGHT;
                ctx.globalAlpha = star.size / 2 * alphaMultiplier; ctx.beginPath(); ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2); ctx.fill();
            }
            ctx.globalAlpha = 1; playerPrevX = player.x; playerPrevY = player.y;
        }

        // --- Crosshair Drawing ---
        function drawCrosshair(ctx) {
            if (usingTouch) return; // Don't draw crosshair on touch devices
            const size = 20; const gap = 5; const thickness = 2; ctx.strokeStyle = COLOR_CROSSHAIR; ctx.lineWidth = thickness;
            ctx.shadowBlur = 10; ctx.shadowColor = COLOR_CROSSHAIR; ctx.beginPath(); ctx.moveTo(mouse.x - size - gap, mouse.y); ctx.lineTo(mouse.x - gap, mouse.y);
            ctx.moveTo(mouse.x + gap, mouse.y); ctx.lineTo(mouse.x + size + gap, mouse.y); ctx.stroke(); ctx.beginPath(); ctx.moveTo(mouse.x, mouse.y - size - gap);
            ctx.lineTo(mouse.x, mouse.y - gap); ctx.moveTo(mouse.x, mouse.y + gap); ctx.lineTo(mouse.x, mouse.y + size + gap); ctx.stroke(); ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, thickness * 1.5, 0, Math.PI * 2); ctx.fillStyle = COLOR_CROSSHAIR; ctx.fill(); ctx.shadowBlur = 0;
        }
        
        // --- Mobile Controls Drawing ---
        function drawMobileControls(ctx) {
            if (!usingTouch || !gameRunning) return;
            // The joystick stick position is now handled by CSS transform, JS updates it.
            if(touchJoystick.active) {
                const stickMaxDist = 30; // Max distance the stick can move from center
                const stickX = touchJoystick.startX + touchJoystick.dx;
                const stickY = touchJoystick.startY + touchJoystick.dy;

                const distFromCenter = Math.min(stickMaxDist, dist(touchJoystick.startX, touchJoystick.startY, stickX, stickY));
                const angle = Math.atan2(stickY - touchJoystick.startY, stickX - touchJoystick.startX);
                
                const finalStickX = touchJoystick.startX + Math.cos(angle) * distFromCenter;
                const finalStickY = touchJoystick.startY + Math.sin(angle) * distFromCenter;

                joystickStick.style.left = `${finalStickX}px`;
                joystickStick.style.top = `${finalStickY}px`;
            } else {
                 joystickStick.style.left = `50%`;
                 joystickStick.style.top = `50%`;
            }
        }


        // === Game Logic Functions ===

        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            usingTouch = isTouchDevice();

            loadGame();
            showScreen('main-menu');

            startGameBtn.addEventListener('click', startGame);
            upgradesBtn.addEventListener('click', () => showScreen('upgrade-screen'));
            backFromUpgradesBtn.addEventListener('click', () => showScreen('main-menu'));
            returnToMainMenuBtn.addEventListener('click', () => showScreen('main-menu'));

            resumeGameBtn.addEventListener('click', resumeGame);
            exitGameBtn.addEventListener('click', endGame);

            if (usingTouch) {
                setupTouchControls();
                document.getElementById('skill-hud').style.display = 'none'; // Hide keyboard skill HUD
            } else {
                setupMouseKeyboardControls();
            }
            createStars();
        }

        function setupMouseKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                if ((e.key.toLowerCase() === 'p' || e.key === 'escape') && gameRunning && !player.isDead) {
                    if (gamePaused) resumeGame(); else pauseGame();
                }
            });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top;
            });
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) mouse.leftPressed = true;
                if (e.button === 2) mouse.rightPressed = true;
            });
            canvas.addEventListener('mouseup', (e) => {
                if (e.button === 0) mouse.leftPressed = false;
                if (e.button === 2) mouse.rightPressed = false;
            });
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        }

        function setupTouchControls() {
            const joystickArea = document.querySelector('.joystick-area');
            const joystickBase = document.querySelector('.joystick-base');

            const handleTouchStart = (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    const touchX = touch.clientX;
                    const touchY = touch.clientY;
                    
                    // Check if touch is within joystick area
                    const joystickRect = joystickArea.getBoundingClientRect();
                    if (!touchJoystick.active && touchX >= joystickRect.left && touchX <= joystickRect.right && touchY >= joystickRect.top && touchY <= joystickRect.bottom) {
                        touchJoystick.active = true;
                        touchJoystick.touchId = touch.identifier;
                        touchJoystick.startX = touchX;
                        touchJoystick.startY = touchY;
                        touchJoystick.currentX = touchX;
                        touchJoystick.currentY = touchY;
                        joystickBase.style.left = `${touchX - joystickRect.left}px`;
                        joystickBase.style.top = `${touchY - joystickRect.top}px`;
                        joystickStick.style.left = `${touchX - joystickRect.left}px`;
                        joystickStick.style.top = `${touchY - joystickRect.top}px`;
                        continue;
                    }

                    // Check action buttons
                    for (const key in touchButtons) {
                        const btn = document.getElementById(touchButtons[key].id);
                        const btnRect = btn.getBoundingClientRect();
                        if (touchX >= btnRect.left && touchX <= btnRect.right && touchY >= btnRect.top && touchY <= btnRect.bottom) {
                            touchButtons[key].active = true;
                            btn.classList.add('active');
                        }
                    }
                }
            };
            
            const handleTouchMove = (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    if (touchJoystick.active && touch.identifier === touchJoystick.touchId) {
                        touchJoystick.currentX = touch.clientX;
                        touchJoystick.currentY = touch.clientY;
                        touchJoystick.dx = touchJoystick.currentX - touchJoystick.startX;
                        touchJoystick.dy = touchJoystick.currentY - touchJoystick.startY;
                        touchJoystick.angle = Math.atan2(touchJoystick.dy, touchJoystick.dx);
                    }
                }
            };

            const handleTouchEnd = (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    if (touchJoystick.active && touch.identifier === touchJoystick.touchId) {
                        touchJoystick.active = false;
                        touchJoystick.touchId = null;
                        touchJoystick.dx = 0;
                        touchJoystick.dy = 0;
                        joystickBase.style.left = `50%`;
                        joystickBase.style.top = `50%`;
                        joystickStick.style.left = `50%`;
                        joystickStick.style.top = `50%`;
                    }
                     // Deactivate any button this touch might have been on
                    for (const key in touchButtons) {
                         // A simple check is to just deactivate all on any touchend. 
                         // For more complex multi-touch, would need to track identifiers per button.
                         if(touchButtons[key].active) {
                            touchButtons[key].active = false;
                            document.getElementById(touchButtons[key].id).classList.remove('active');
                         }
                    }
                }
            };

            mobileControlsContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
            mobileControlsContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
            mobileControlsContainer.addEventListener('touchend', handleTouchEnd, { passive: false });
            mobileControlsContainer.addEventListener('touchcancel', handleTouchEnd, { passive: false });
        }


        function startGame() {
            player = new Player();
            updatePlayerStatsFromUpgrades();
            enemies = []; playerProjectiles = []; particles = []; lightningEffects = []; waveEffects = []; player.activeLaserEffect = null;
            currentScore = 0; currentWave = 0; enemiesSpawnedThisWave = 0; lastEnemySpawnTime = 0; waveTextDisplayTime = performance.now();
            playerPrevX = player.x; playerPrevY = player.y;
            startNextWave();
            showScreen('game');
        }

        function endGame() {
            if (!gameRunning && !gamePaused) return;
            gameRunning = false; gamePaused = false;
            cancelAnimationFrame(animationFrameId);
            playerMoney += currentScore;
            if (currentScore > highScore) highScore = currentScore;
            saveGame();
            finalScoreDisplay.textContent = currentScore;
            finalWaveDisplay.textContent = currentWave;
            gainedMoneyDisplay.textContent = currentScore;
            showScreen('game-over-menu');
        }

        function pauseGame() { gamePaused = true; cancelAnimationFrame(animationFrameId); showScreen('pause-menu'); }
        function resumeGame() { gamePaused = false; showScreen('game'); }

        function startNextWave() {
            currentWave++; enemiesSpawnedThisWave = 0; lastEnemySpawnTime = 0;
            waveTextDisplayTime = performance.now();
            enemiesInWave = WAVE_INITIAL_ENEMY_COUNT + (currentWave - 1) * WAVE_ENEMY_COUNT_PER_WAVE;
        }

        function spawnEnemy() {
            if (enemiesSpawnedThisWave >= enemiesInWave) return;
            const enemyChoices = [];
            if (currentWave >= 1) enemyChoices.push({ type: 'Grunt', hp: 15, speed: 120, radius: 10, color: COLOR_ENEMY_GRUNT, behavior: 'chase_oscillate', score: 10 });
            if (currentWave >= 2) enemyChoices.push({ type: 'Scout', hp: 10, speed: 200, radius: 12, color: COLOR_ENEMY_SCOUT, behavior: 'chase_oscillate', score: 15 });
            if (currentWave >= 4) enemyChoices.push({ type: 'Brute', hp: 40, speed: 80, radius: 25, color: COLOR_ENEMY_BRUTE, behavior: 'chase_direct', score: 30 });
            const def = enemyChoices[Math.floor(Math.random() * enemyChoices.length)];
            let hp = def.hp * (1 + (currentWave - 1) * WAVE_ENEMY_HP_SCALING);
            let speed = def.speed * (1 + (currentWave - 1) * WAVE_ENEMY_SPEED_SCALING);
            let x, y; const side = Math.floor(Math.random() * 4);
            if (side === 0) { x = Math.random() * CANVAS_WIDTH; y = -ENEMY_SPAWN_OFFSET; } 
            else if (side === 1) { x = CANVAS_WIDTH + ENEMY_SPAWN_OFFSET; y = Math.random() * CANVAS_HEIGHT; } 
            else if (side === 2) { x = Math.random() * CANVAS_WIDTH; y = CANVAS_HEIGHT + ENEMY_SPAWN_OFFSET; } 
            else { x = -ENEMY_SPAWN_OFFSET; y = Math.random() * CANVAS_HEIGHT; }
            enemies.push(new Enemy(def.type, x, y, hp, speed, def.radius, def.color, def.behavior, def.score));
            enemiesSpawnedThisWave++;
        }

        function checkCollisions() {
            for (let i = playerProjectiles.length - 1; i >= 0; i--) {
                const proj = playerProjectiles[i]; if (!proj.isActive) continue;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j]; if (enemy.isDead) continue;
                    if (dist(proj.x, proj.y, enemy.x, enemy.y) < proj.radius + enemy.radius) { enemy.takeDamage(proj.damage); proj.isActive = false; break; }
                }
            }
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i]; if (enemy.isDead) continue;
                if (dist(player.x, player.y, enemy.x, enemy.y) < player.radius + enemy.radius) {
                    player.takeDamage(10); enemy.takeDamage(5);
                    const angleToPlayer = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    player.x += Math.cos(angleToPlayer) * 15; player.y += Math.sin(angleToPlayer) * 15;
                    player.x = clamp(player.x, player.radius, CANVAS_WIDTH - player.radius); player.y = clamp(player.y, player.radius, CANVAS_HEIGHT - player.radius);
                }
            }
            if (player.skillRMB.isActive && player.activeLaserEffect) {
                const { x1, y1, x2, y2 } = player.activeLaserEffect; const lineLengthSq = (x2 - x1)**2 + (y2 - y1)**2;
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i]; if (enemy.isDead || lineLengthSq === 0) continue;
                    let t = ((enemy.x - x1) * (x2 - x1) + (enemy.y - y1) * (y2 - y1)) / lineLengthSq; t = Math.max(0, Math.min(1, t));
                    const closestX = x1 + t * (x2 - x1); const closestY = y1 + t * (y2 - y1);
                    if (dist(closestX, closestY, enemy.x, enemy.y) < enemy.radius + player.activeLaserEffect.width / 2) enemy.takeDamage(player.skillRMB.damagePerFrame * deltaTime * 60);
                }
            }
        }


        function gameLoop(timestamp) {
            if (!gameRunning || gamePaused) { cancelAnimationFrame(animationFrameId); return; }
            deltaTime = (timestamp - lastTime) / 1000; lastTime = timestamp;

            player.update(deltaTime);
            enemies = enemies.filter(enemy => { enemy.update(deltaTime); return !enemy.isDead; });

            const spawnInterval = Math.max(WAVE_SPAWN_INTERVAL_MIN, WAVE_SPAWN_INTERVAL_BASE - (currentWave - 1) * WAVE_SPAWN_INTERVAL_DECREASE);
            if (enemiesSpawnedThisWave < enemiesInWave && (performance.now() - lastEnemySpawnTime > spawnInterval)) { spawnEnemy(); lastEnemySpawnTime = performance.now(); }
            if (enemies.length === 0 && enemiesSpawnedThisWave >= enemiesInWave) startNextWave();

            playerProjectiles = playerProjectiles.filter(proj => { proj.update(deltaTime); if (!proj.isActive) pool.returnProjectile(proj); return proj.isActive; });
            particles = particles.filter(p => { p.update(deltaTime); if (!p.isActive) pool.returnParticle(p); return p.isActive; });
            lightningEffects = lightningEffects.filter(e => { e.lifetime -= deltaTime; return e.lifetime > 0; });
            waveEffects = waveEffects.filter(e => { e.radius += e.speed * deltaTime; e.alpha = 1 - (e.radius / e.maxRadius); return e.radius < e.maxRadius; });

            checkCollisions();

            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawStars(ctx);
            player.draw(ctx);
            playerProjectiles.forEach(proj => proj.draw(ctx));
            enemies.forEach(enemy => enemy.draw(ctx));
            particles.forEach(p => p.draw(ctx));

            lightningEffects.forEach(e => {
                ctx.globalAlpha = e.lifetime / 0.2; ctx.beginPath(); ctx.moveTo(e.x1, e.y1);
                for (let i = 1; i <= 5; i++) {
                    const frac = i / 5; const midX = e.x1 + (e.x2 - e.x1) * frac; const midY = e.y1 + (e.y2 - e.y1) * frac;
                    const perpAngle = Math.atan2(e.y2 - e.y1, e.x2 - e.x1) + Math.PI / 2; const offset = (Math.random() - 0.5) * 20;
                    ctx.lineTo(midX + Math.cos(perpAngle) * offset, midY + Math.sin(perpAngle) * offset);
                }
                ctx.lineTo(e.x2, e.y2); ctx.strokeStyle = COLOR_SKILL_Q; ctx.lineWidth = 3; ctx.shadowBlur = 10; ctx.shadowColor = COLOR_SKILL_Q; ctx.stroke();
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            });
            waveEffects.forEach(e => {
                ctx.globalAlpha = e.alpha; ctx.strokeStyle = COLOR_SKILL_E_INNER; ctx.lineWidth = 3; ctx.shadowBlur = 15; ctx.shadowColor = COLOR_SKILL_E_INNER;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius * 0.8, 0, Math.PI * 2); ctx.stroke();
                ctx.strokeStyle = COLOR_SKILL_E_OUTER; ctx.lineWidth = 8; ctx.shadowBlur = 25; ctx.shadowColor = COLOR_SKILL_E_OUTER;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2); ctx.stroke(); ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            });
            if (player.activeLaserEffect) player.activeLaserEffect.draw(ctx);

            if (performance.now() - waveTextDisplayTime < WAVE_TEXT_DURATION) {
                const elapsed = performance.now() - waveTextDisplayTime; let alpha = 0, scale = 1;
                if (elapsed < 500) { alpha = elapsed / 500; scale = 0.5 + 0.5 * alpha; } 
                else if (elapsed < WAVE_TEXT_DURATION - 500) { alpha = 1; scale = 1.5; } 
                else { alpha = 1 - (elapsed - (WAVE_TEXT_DURATION - 500)) / 500; scale = 1.5 - 0.5 * (1 - alpha); }
                alpha = clamp(alpha, 0, 1); scale = clamp(scale, 0.5, 1.5);
                ctx.save(); ctx.globalAlpha = alpha; ctx.fillStyle = COLOR_PLAYER; ctx.font = `bold ${70 * scale}px Arial`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.shadowBlur = 20; ctx.shadowColor = COLOR_PLAYER;
                ctx.fillText(`WAVE ${currentWave}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2); ctx.restore();
            }
            
            drawCrosshair(ctx);
            drawMobileControls(ctx); // Draw mobile controls overlay
            updateHUD();

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        window.onload = initGame;
    </script>
</body>
</html>